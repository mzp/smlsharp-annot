SML# version 1.0.3 (released on 2012-06-25)

Fixed bugs:
* Fixed a bug of type inference phase.
* Fixed a bug that some form of polymorphic record selector caused a
  runtime error.
* Fixed a bug that accepted duplicate labels in a record expression
  in some cases.
* Fixed a bug of evaluation of comparison operators with two constant
  literals.
* Fixed a bug of elaboration of "withtype" of "abstype" declaration.

-----------------------------------------------------------------------------
SML# version 1.0.2 (released on 2012-05-14)

Fixed bugs:
* Some illegal SQL select queries were accepted due to lack of a type
  unification.
* Using capital letters in an SQL query caused runtime error when the
  query is sent to a database server.
* Real.fmt returned wrong results. This bug was also affected to the
  value printer of the interactive mode.
* Name evaluation passed duplicate link symbols in a case that those
  symbols are declared in different interface files.
* "make" was aborted due to no rule on .desc files if --enable-fast-build
  is enabled.

-----------------------------------------------------------------------------
SML# version 1.0.1 (released on 2012-04-24)

Fixed bugs:
* Vector.update caused segentation fault.
* Bound type variables in a record kind caused a BUG exception.
* opeining a structure containing overloaded ids caused a BUG exception.

Improvements:
* builtin-primitives are now printed in the interactive session.
* link time warning about tmpnam(3) is suppressed.
* --enable-fast-build option is added to configure script.
  This option reduces the time for building SML# compiler by
  reusing assembly code of minismlsharp.

-----------------------------------------------------------------------------
SML# version 1.0.0 (released on 2012-04-06)

SML# 1.0.0 is the first fully functional version of the SML# language
system. It supports all the features the SML# project had initially
aimed at, including:

 *  Record polymorphism.
 *  Direct interoperability with the C langauge.
 *  Seamless integration of SQL.
 *  True separate compilation and linking

In addition to these goals we had set, we have also completed the
development of:

 *  Native multithread support on multicore hardware.
 *  A fully concurrent non-moving GC.

These two feature have not yet been well tested, and are not supported
in this version. (Multithread support is turned off by default and the
concurrent GC is not included.) These two features will soon be
available in a forthcoming SML# version. 

For the details, see the SML# 1.0.0 documentations.
 * The Japanese version:
   http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/1.0/ja/index.xhtml
 * The English version:
   http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/1.0/en/index.xhtml
The documents contain an overview of the SML# language, and a
comprehensive tutorial, which provides sufficient information to start
writing SML# programs.

Enjoy cool and practical programming with SML# 1.0.0

-----------------------------------------------------------------------------
SML# version 0.90 (released on 2011-09-14)

1. Overview

SML# 0.90 is an experimental release of the forthcoming new generation
of SML#.

This 0.90 version is a separate compilation system for SML# (which is
backward compatible with the Standard ML). This version complements
the interactive compiler of 0.60 series.

The functionality of separate compilation is outlined in the following
section. A detailed document will be released in the forthcoming SML#
1.00, which combines this separate compilation system and the
interactive compiler. Meanwhile, the interested programmers and
researchers can contact us for more details. 


2. Separate Compilation Overview

2.1 smlsharp command

Typical functionalities of the SML# 0.90 compiler command include the
following.

(1) Compile one source file into an object file. The command line

  % smlsharp -c foo.sml

reads foo.sml and produces foo.o, consulting with its interface
file. The programmer can specify an interface file of foo.sml in one
of the following two ways:
* to include a compiler directive line:
  _interface "<filename>"
* to create a file foo.smi in the same directory.

(2) Link object files. The command line

 % smlsharp A.smi

locates all the object files referenced in A.smi, links them together
(by invoking the system linker, ld) and produces an executable file,
whose default file name is a.out. 

(3) Compile and link a source file. The command line

 % smlsharp A.sml

compiles A.sml, links it with all the files referenced in A.smi
and generates a.out.

In (2), (3), if the source file references external C functions
through _import declarations, then the programmer should 
list their object files (generated by C complier) as in

 % smlsharp A.sml clib.a cfun.o

In addition, smlsharp command performs a number of other things
related to compiling and linking.

2.2 Interface language

To separately compile a source file, foo.sml, the programmer need to
write its interface file, whose default name is foo.smi. This
interface file specifies the resources foo.sml requires and those that
are provided by foo.sml.

The syntax of an interface file consists of the following.
i. a list of require specification of the following form
  _require <interface file name>

ii. a list of provide specifications.
Its syntax is defined roughly as follows.

   <itopdec> ::= <idecl> | <ifundecl>
   <idecl> ::= val <valdesc>
            |  type <itypbind>
            |  eqtype <tyvarSeq> id (= <ty>)
            |  datatype <idatbind>
            |  datatype <id> = datatype <longid>
            |  exception <exbind>
            |  structure <id> = <istrexp>
            |  infix <n> <id>
            |  infixr <n> <id>
            |  noninfix <n> <id>
<itypbind> ::= <tyvarSeq> <id> = <ty>
            |  <tyvarSeq> <id> ( = <ty> )
<idatbind> ::= <tyvarSeq> <id> = <conbinds> [and <idatbind>]
            |  <tyvarSeq> <id> ( = <conbinds> [and <idatbind>] )
<istrexp>  ::= struct <idecl-seq> end
<ifundec>  ::= functor <id> ( <id> : <sigexp> )  = <istrexp>

Nonterminals not defined are analogous to those of Standard ML
signature.

They resemble Standard ML signatures but they also need to 
specify the information needed for smlsharp to compile a 
source that reference this interface into object code.
Extra syntax are there for this purpose.


-----------------------------------------------------------------------------
SML# version 0.62 (released on 2010-12-17)

1. Overview

This is a patch release of SML# 0.60 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- added static allocation optimization.
  This optimization allocates constant records and closures to memory
  at compile time. This optimization is available only for native code
  and enabled by default. To disable this optimization, specify
  --xdoStaticAllocation=no option to the command line.
- restructured the prelude library to improve performance.
  It also reduces time for compiling the native prelude library.
- rewrote register allocation phase.
  New register allocation phase is based on Appel-George's iterative
  register allocator with register coalescing. The register coalescing
  is enabled by default. To disable the coalescing, specify
  --xdoRegisterCoalescing=no option to the command line.
- enabled generational version of the non-moving bitmap marking
  garbage collector by default.
  This collector is available only for native code.
- added support for SQL commands for transaction control.
  You may write "begin", "commit" or "rollback" command in a _sql
  expression as a SQL command.
- added SQL.queryString and SQL.commandString primitive function.
- fixed bug of handling real variables defined at toplevel in native
  code generation.
- fixed type errors of intermediate representations for native code
  generation.
- refactored native code backend.

-----------------------------------------------------------------------------
SML# version 0.61 (released on 2010-11-26)

1. Overview

This is a patch release of SML# 0.60 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- added a feature that CConfig creates a cache file for check results.
- added Pointer structure.
  This structure is experimental and provides primitive functions for
  C pointers such as pointer arithmetics and memory access.

-----------------------------------------------------------------------------
SML# version 0.60 (released on 2010-11-12)

1. Overview

An experimental release of a new feature of SML#. 
Only the source package is provided. 

2. The new feature

The major new feature of SML# 0.60 is seamless interoperability with
database systems. 

In this version, (a subset of) SQL is directly available as
first-class SML# expressions and can be freely combined with any other
language constructs in SML#. The SML# type system with record
polymorphism always infers a principal type for any type consistent
expression involving SQL query expressions. The compiler separates SQL
queries and delegates them to a database server. 

To show a simple example, consider the following an SQL query
    SELECT name, age
    FROM person 
    WHERE age <= 25
This is a function which takes a connection to a database that contains
"person" table having "age" column of type integer and name column of
any SQL supported atomic values possibly containing null. The
following shows an SML# session defining this query:
 # val young =
       _sql db =>
            select #person.name as name, #person.age as age
            from #db.people as person
            where SQL.<= (#person.age, 35);
 val young = fn
   : ['a#{people:'b},
      'b#{age:int, name:'d},
      'c,
      'd::{int, word, char, string, real, 'e option},
      'e::{int, word, char, bool, string, real}.
      ('a, 'c) SQL.db -> {age: int, name: 'd} SQL.query]
"'e option" represents values possibly containing null. The inferred
type is indeed a principal type of "young". In addition to SQL
queries, database servers and database connections are also typed
first-class citizens. These feature allow the SML programmer to write
a typed polymorphic higher-order programs with SQL queries. 

In this version, only PostgreSQL is supported; MySQL binding will be
added in a future release.

For a brief description on how to use this feature, see the web page: 
http://www.pllab.riec.tohoku.ac.jp/smlsharp/?FeatureDatabaseIntegration

3. Oteher changes and improvements

none.

-----------------------------------------------------------------------------
SML# version 0.58 (released on 2010-10-16)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- fixed a bug that String.sub returns a negative integer if given
  string contains a non-ASCII character.
- fixed a bug of printing string values on interactive mode.
- fixed a bug of compilation of polymorphic flexible record patterns.
- refined messages of type errors due to record kinds.

-----------------------------------------------------------------------------
SML# version 0.57 (released on 2010-10-01)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- Updated parser and improved conformance with the Definition.
 - accept unmatched "*)".
 - reject "*" as a tycon.
 - reject integer starting with "0" as a record label.
- Updated the build system so that SML# can be built only by MLton.
 If --with-mlton option is specified to configure, and the build
 system uses MLton (without SML/NJ) to compile SML# compiler and
 other tools.

-----------------------------------------------------------------------------
SML# version 0.56 (released on 2010-09-17)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- refined several Makefiles and .cm files.

[SMLDoc]
- fixed errors in Makefile.

[mlb2use]
- added support for SML/NJ .cm files.

-----------------------------------------------------------------------------
SML# version 0.55 (released on 2010-09-03)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- fixed a bug of parsing unclosed comments and unclosed string
 literals. They now causes a parse error.

-----------------------------------------------------------------------------
SML# version 0.54 (released on 2010-08-20)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. the Basis test suite

This version includes the first public version of our test suites for
Basis Library.

One of advantages of Standard ML is that implementations share the
specification of the language and Basis library.  It encourages
portability and stable long life of softwares written in Standard ML.

We present a test suite for Standard ML Basis library.  Compiler
implementors can use it to check the conformance of their implementation
to the Basis specification.  We hope that this test suite helps to
eliminate differences remaining among implementations of Basis library.

This test suite is at smlsharp/SMLUnit/basis/ in the SML# source package.

3. Other changes and improvements

[SML#]
- rewrote Array2 from scratch to fix problems.
- added Word8Array2.
- added CharArray2.
- implemented overflow check in Int.{scan, fromLarge, div, mod, quot, rem}.
- implemented overflow check in IntInf.toInt.
- fixed bugs of IntInf.log2.
- fixed a bug of Real.split on cygwin.
- added error checks to Date functions.

-----------------------------------------------------------------------------
SML# version 0.53 (released on 2010-08-06)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- fixed a bug of raising Div exception.
- fixed a bug of floating-point literal compilation in native backend.
- fixed a problem of SIGINT handling.
- fixed many bugs in Array, Char, CharVector, Real, IEEEReal, String,
 VectorSlice, and Word, Word8 structures.
- implemented String.scan, String.concatWith, and Real.nextAfter.
- improved conformance of IEEEReal structure with the Basis library
 specification.

[SMLUnit]
* added assert functions for tuples and datatypes defined in Basis
  structures.
* changed the type of assert functions to return a unit.

-----------------------------------------------------------------------------
SML# version 0.52 (released on 2010-07-23)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
* fixed a bug of an alternative implementation of signbit in the native
  runtime. This fix affects several primitive functions defined in Real
  structure.
* fixed a bug of functor management and global symbol resolution in
  native code backend.

-----------------------------------------------------------------------------
SML# version 0.51 (released on 2010-07-09)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
* slightly improved compilation for "orelse" and "andalso".
* slightly speed up of booting interactive mode by compacting pickled
  context of the prelude.
* refined unification algorithm to print more reasonable error messages.

[SMLUnit]
* added support files for MLton.

[mlb2use]
* fixed a bug of dealing with backslashes.

-----------------------------------------------------------------------------
SML# version 0.50 (released on 2010-06-25)

1. Overview

An experimental release of a new feature of SML#. 
Only the source package is provided. 

2. The new feature

The major new feature of SML# 0.50 is first-class overloading.

First-class overloading may not be ardent wanted by ordinary SML
programmers, but we find this feature essential in our development of
seamless interoperability with database system, which we shall include
in our near future release.

This version implements a lightweight first-class overloading mechanism
that is readily realized by SML#'s polymorphic record compilation.

With this extension, overloaded operators such as + and > are now
first-class values having a polymorphic type that represents their
overloaded status, as seen in the following example:
 # op +;
 val it = fn
     : ['a::{int, IntInf.int, real, Real32.real, word, Word8.word}.
        'a * 'a -> 'a
 # fun sumList nil z = z
 >   | sumList (h::t) z = sumList t (h+z);
 val sumList = fn
     : ['a::{int, IntInf.int, real, Real32.real, word, Word8.word}.
        'a list -> 'a -> 'a]
 # sumList [1,2,3] 0;
 val it = 6 : int
 # sumList [1.1,2.2,3.3] 0.0;
 val it = 6.6 : real
where "::{....}" in 'a::{....} is an overload kind, restricting
possible instances of type variable 'a.

Any operator having the following two properties can be supported.
1. Its overloaded nature is representable as a polymorphic type using
   overload kinds. Its type can contain multiple overloaded type
   variables. The instance types in their overload kinds may also
   contain type variables possibly with overload kind restriction.
2. Each instance corresponds to a set of type instances specified by
   ground type constructors and wild card "_".
For example, the type
  ['a#{int, real, 'b list, 'c array}, 'b#{bool, char}, 'c#{int, bool}.
   'a * 'a -> 'a]
represents an overloaded binary operator having the instances for
{int, real, bool list, char list, int array, bool array}. These
correspond to the following instantiations of 'a, 'b, and 'c:
  [int,_,_] for int op
  [real,_,_] for real op
  [bool list, bool, _] for bool list op
  [char list, char, _] for bool list op
  [int array, _, int] for int array op
  [bool array, _, bool] for bool array op

In the currently version, overloaded operator declaration is not yet
made available to the programmer. We plan to include a special
syntax for this purpose in future version.

3. Oteher changes and improvements

[SML#]
* fixed a bug of pretty-printing for evaluation results in interactive mode.
* fixed a bug of equality type inference.
* fixed a bug of introducing dummy types due to value restrictions.
* made type printers much prettier.

[SMLFormat]
* fixed a bug in handling newline indicators in nested guards.
* updated documents.

[OLE/SML#]
* a minor-change of OLE_DECIMAL signature.
* updated a sample code using MS Excel.

-----------------------------------------------------------------------------
SML# version 0.43 (released on 2010-06-11)

1. Overview

This is an release of SML# 0.42. This version is still experimental
and not intended to replace SML# 0.31.

2. Changes and improvements

[SML#]
* added native code generation for Windows. Both mingw and cygwin
  are supported.
* improved native callback function generation so that C program
  can call ML functions anytime.
* added interoperability for float (32bit floating point number)
  to the native code generation.
* fixed a bug of native code selection.
* improved accuracy of native code compilation for floating point
  constant literals.
* implemented Real32 structure.
* fixed a bug of Array.array.
* fixed a bug of printing an exception.
* refined UnmanagedString.export.
* fixed a bug of native version of UnmanagedMemory.export.
* fixed a bug of smlsharp2exe.
* fixed a buffer overflow in the runtime.

[OLE/SML#, .NET/SML#]
* changed module configuration of OLE library.
* supported OLE SAFEARRAY of builtin types of .NET, except for char.
* fixed a minor problem in handling a literal in C# code.

-----------------------------------------------------------------------------
SML# version 0.42 (released on 2010-05-28)

1. Overview

This is an bug-fix release of SML# 0.41. This version is still
experimental and not intended to replace SML# 0.31.

2. Changes and improvements

* fixed a bug of hiding int values in result printings after open Int.
* fixed a bug of user type variable unification.
* fixed a bug of Word32.fromLargeWord.
* fixed a bug of compiling negative IntInf constant literals.
* fixed a bug of equality of exceptions.
* suppressed diagnosis messages printed by native code backend.
* improved result printing for hidden types.
* implemented a few functions in Real32.real.
* SMLUnit: added Assert.assertEqualByCompare.
* Java/SML#: fixed conflictions between Java identifiers and SML keywords.
* .NET/SML#: added support for all built-in datatypes of C#.
* OLE/SML#: added support for I2, UI2, I8, UI8, R4 and DECIMAL.
* OLE/SML#: fixed problems in passing I4 and I1.

-----------------------------------------------------------------------------
SML# version 0.41 (released on 2010-05-14)

1. Overview

This is a bug-fix release of SML# 0.40. This version is still
experimental and not intended to replace SML# 0.31.

2. Changes and improvements

* fixed problems of building SML# on Windows.
* smlformat command now raises an error if no file is specified.
* fixed a bug of isAlphaNum of LMLML.
* fixed a bug of Word32.toLargeIntX.
* fixed a bug of String.fromString and String.fromCString.
* changed LMLML interface.
* added and updated sample code for Java/SML#.

-----------------------------------------------------------------------------
SML# Version 0.40 (released on 2010-04-30)

1. Overview

This is an experimental release for testing new backend and runtime
system. It is not intended to replace SML# 0.30.

2. New features and improvements of SML#

* Native code generation for x86 Linux and Intel-based Mac OS X.

  The native code compiler backend produces native object files that
  can be linked with C libraries by standard linker (e.g. ld
  command) without any unusual extension and hand-written glue code.

  To try the native code generation, invoke SML# comiler with
  --native option. The compiler produces an executable file named
  "a.sme". See SML# website for details.

* Runtime library for native code.

  This library also includes non-moving bitmap marking garbage
  collector.

* Experimental module flattening and ID allocation phases.

3. Other improvements

* Java/SML# interface:
  * fixed a bug in renaming overloaded Java methods and constructors
  * supported java array of float and long.
  * improved Java exception handling.
  * minor-changed Java library interface.

-----------------------------------------------------------------------------
SML# Version 0.30 (released on 2007-07-02)

1. Overview

The major change from SML# 0.20 is implementation of several
optimization phases in the SML# compiler, among which the most
significant is Record Unboxig described below.


2. Distribution Package

The SML# distribution package is re-organized to contain the SML#
compiler and its supporting tools in one package. The distribution
package is available in the following forms.
(a) Source tar file.
  smlsharp-0.30.tar.gz
(b) Mac OS X universal binary (after 10.4)
  smlsharp-0.30-Universal-Installer.dmg
(c) Windows binary installer
   smlsharp-0.30-mingw.exe
Each of the above package contains the following:
* the SML# compiler and its supporting library including LMLML
* SMLFormat (a pretty printer generator)
* SMLDoc (a document generation tool)
* SMLUnit (a unit test support tool)

3. Contact information and mailing list
- The contact address of the SML# development team.
  smlsharp @ pllab . riec . tohoku . ac . jp 
- The SML# mailing list:
  smlsharp-list @ pllab . riec . tohoku . ac . jp  
  This list is for general discussions on the SML# language, the
  compiler and its supporting tools. This is open to everyone.
  For more details, visit the "Contact Us" page of the SML# web.


4. New Features of the SML# compiler
4.1 Printer Control
The following structure is added to control the printer used to print
binding information in the interactive session

SMLSharp.Control.Printer 
: sig
    val getColumns : unit  -> int
    val getMaxDepth : unit  -> int option
    val getMaxRefDepth : unit  -> int
    val getMaxWidth : unit  -> int option
    val setColumns : int  -> unit
    val setMaxDepth : int option  -> unit
    val setMaxRefDepth : int  -> unit
    val setMaxWidth : int option  -> unit
  end

4.2 Optimization
The following optimization phases have been implemented.

(a) Record Unboxing
This optimization attempts to "unbox" tuples/records by flattening
component tuples and changing top-level tuples to multiple value
passing. It is a type-directed source-to-source transformation that
does not seem to be considered in existing literature or compiler.
The required type based analysis is quite simple but shown to be very
effective. Experiments on this technique shown a 27% speed-up in the
lexgen benchmark and a 21% speed-up in mlyacc benchmark. The compiler
switch 
 --xdoRecordUnboxing=yes/no 
enables/disables this optimization. It is enabled by default. 

(b) Record Alignment
To meat architecture requirements, the SML# compiler aligns record
component such as (unboxed) floating point values to double-word
boundary by inserting padding words. This would introduce some runtime
overhead, especially in the presence of polymorphism. The Record
Alignment optimization attempts to minimize this overhead cost as much
as possible. The compiler switch 
  --xalignRecord=yes/no
enables/disables this optimization. It is enabled by default. 

(c) Representation Analysis
This optimization attempts to reduce the overhead due to type-directed
compilation for those polymorphic functions that are instantiated to
types representing the same runtime property by statically computing
the type attributes. The compiler switch 
 --xdoRepresentationAnalysis=yes/no
enables/disables this optimization. It is enabled by default. 

(d) Other Conventional Optimizations.
In addition to those new type-based optimization, the version 0.30
also implements the following conventional optimizations.
 Optimization                   Compiler Switch 
 constant folding               --xdoConstantFolding=yes/no
 common expression elimination  --xdoCommonExpressionElimination=yes/no
 useless code elimination       --xdoUselessCodeElimination=yes/no
 stack slot minimization        --xdoStackReallocation=yes/no

4.3 Other Changes
(a) SML# executable file name
In the batch-mode, the current SML# executable file name can be
obtained by the function:
  SMLSharp.CommandLine.executableImageName : unit -> string option
In the interactive mode, it returns NONE.

(b) "Shebang" line in a source file.
 By default, the SML# compiler ignores the first if it begins "#!"
 (shebang line). This feature is used to execute SML# file in a Unix 
 shell as shown in the following example.
   $ cat foo.sml
   #!/usr/local/bin/smlsharp
   print "foo\n";
   $ ./foo.sml
   foo
The compiler switch 
  --xskipShebang=yes/no
enables/disables this feature. It is enabled by default.

4.4 bug fixes
Several minor bugs are fixed:
* Make & install fails on Free BSD
* Make fails for SMLUnit, SMLDoc, and SMLFormat on Unix/Linux due to
  improper newline codes in their source files.
* Tests and benchmarks fail in the system made with SML/NJ 110.63
* "smlsharp -c" command does not report error messages properly.
* Functions fromLarge, toLarge, toLargeX were missing in Word[N] structures.
* TextIO.flushOut sometimes fails to flush the output buffer
* Signature mismatch error due to difference of constructor order in
  datatype def and spec.
* Missing error check for a layered pattern with a long id as its left pattern


5. Tools
5.1 SMLFormat
Three constructors, MaxDepthOfGuards, MaxWidthOfGuards and CutOverTail,
have been added to SMLFormat.parameter datatype. These can be used to
limit the size of the formatted string.

5.2 SMLUnit
The following two assert functions have been added to SMLUnit.Assert
structure. 
 val assert : string -> bool -> unit
 val assertSameArray : 'a array assertEqual

-----------------------------------------------------------------------------
SML# Version 0.20 (released  on 2007-03-30)
