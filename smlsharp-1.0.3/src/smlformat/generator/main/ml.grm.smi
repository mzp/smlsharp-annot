_require "../../../basis/main/StringCvt.smi"
_require "../../../basis/main/List.smi"
_require "../../../basis/main/String.smi"
_require "../../../basis/main/Char.smi"
_require "../../../basis/main/Array.smi"
_require "../../../basis/main/ListPair.smi"
_require "../../../basis/main/Int.smi"
_require "../../../basis/main/General.smi"
_require "../../../basis/main/binary-op.smi"
(*
_require "../../../basis.smi"
*)

_require "../../../ml-yacc-lib.smi"
_require "Ast.smi"
_require "AstUtil.smi"
_require "FormatTemplate.smi"
_require "ml.grm.sig"

structure MLLrVals = 
struct
  structure ParserData =
  struct
    type pos = int
    type svalue (= boxed)
    type arg = unit
    type result = Ast.dec
    structure LrTable =
    struct
      datatype pairlist = datatype LrParser.Token.LrTable.pairlist
      datatype state = datatype LrParser.Token.LrTable.state
      datatype term = datatype LrParser.Token.LrTable.term
      datatype nonterm = datatype LrParser.Token.LrTable.nonterm
      datatype action = datatype LrParser.Token.LrTable.action
      type table = LrParser.Token.LrTable.table
      val numStates : table -> int
      val numRules : table -> int
      val describeActions : table -> state -> (term,action) pairlist * action
      val describeGoto : table -> state -> (nonterm,state) pairlist
      val action : table -> state * term -> action
      val goto : table -> state * nonterm -> state
      val initialState : table -> state
      exception Goto = LrParser.Token.LrTable.Goto
      val mkLrTable : {actions : ((term,action) pairlist * action) array,
                       gotos : (nonterm,state) pairlist array,
                       numStates : int, numRules : int,
                       initialState : state} -> table
    end
    structure Token =
    struct
      structure LrTable =
      struct
        datatype pairlist = datatype LrParser.Token.LrTable.pairlist
        datatype state = datatype LrParser.Token.LrTable.state
        datatype term = datatype LrParser.Token.LrTable.term
        datatype nonterm = datatype LrParser.Token.LrTable.nonterm
        datatype action = datatype LrParser.Token.LrTable.action
        type table = LrParser.Token.LrTable.table
        val numStates : table -> int
        val numRules : table -> int
        val describeActions : table -> state ->
                              (term,action) pairlist * action
        val describeGoto : table -> state -> (nonterm,state) pairlist
        val action : table -> state * term -> action
        val goto : table -> state * nonterm -> state
        val initialState : table -> state
        exception Goto = LrParser.Token.LrTable.Goto
        val mkLrTable : {actions : ((term,action) pairlist * action) array,
                         gotos : (nonterm,state) pairlist array,
                         numStates : int, numRules : int,
                         initialState : state} -> table
      end
      datatype token = datatype LrParser.Token.token
      val sameToken : ('a,'b) token * ('a,'b) token -> bool
    end
    structure Actions =
    struct
      val actions : int * pos *
                    (LrTable.state * (svalue * pos * pos)) list * arg ->
                    LrTable.nonterm * (svalue * pos * pos) *
                    (LrTable.state *(svalue * pos * pos)) list
      val void : svalue
      val extract : svalue -> result
    end
    structure EC =
    struct
      val is_keyword : LrTable.term -> bool
      val noShift : LrTable.term -> bool
      val preferred_change : (LrTable.term list * LrTable.term list) list
      val errtermvalue : LrTable.term -> svalue
      val showTerminal : LrTable.term -> string
      val terms: LrTable.term list
    end
    val table : LrTable.table
  end
  structure Tokens =
  struct
    type ('a,'b) token = ('a,'b) LrParser.Token.token
    type svalue = ParserData.svalue
    val ASSOCINDICATOR : {cut:bool, direction: FormatTemplate.assocDirection,
                          strength:int} * 'a * 'a
                         -> (svalue,'a) token
    val FORMATINDICATOR : {newline:{priority: FormatTemplate.priority} option,
                           space:bool} * 'a * 'a
                          -> (svalue,'a) token
    val STARTOFINDENT : int * 'a * 'a -> (svalue,'a) token
    val NEWLINE : 'a * 'a -> (svalue,'a) token
    val LOCALFORMATTAG : string * 'a * 'a -> (svalue,'a) token
    val FORMATTAG : 'a * 'a -> (svalue,'a) token
    val HEADERTAG : 'a * 'a -> (svalue,'a) token
    val DESTINATIONTAG : 'a * 'a -> (svalue,'a) token
    val FORMATPARAMSTAG : 'a * 'a -> (svalue,'a) token
    val FORMATTERTAG : 'a * 'a -> (svalue,'a) token
    val PREFIXTAG : 'a * 'a -> (svalue,'a) token
    val DITTOTAG : 'a * 'a -> (svalue,'a) token
    val FORMATCOMMENTEND : 'a * 'a -> (svalue,'a) token
    val FORMATCOMMENTSTART : 'a * 'a -> (svalue,'a) token
    val AQID : string * 'a * 'a -> (svalue,'a) token
    val OBJL : string * 'a * 'a -> (svalue,'a) token
    val ENDQ : string * 'a * 'a -> (svalue,'a) token
    val BEGINQ : 'a * 'a -> (svalue,'a) token
    val VECTORSTART : 'a * 'a -> (svalue,'a) token
    val FUNSIG : 'a * 'a -> (svalue,'a) token
    val ANDALSO : 'a * 'a -> (svalue,'a) token
    val ORELSE : 'a * 'a -> (svalue,'a) token
    val RPAREN : 'a * 'a -> (svalue,'a) token
    val RBRACKET : 'a * 'a -> (svalue,'a) token
    val RBRACE : 'a * 'a -> (svalue,'a) token
    val LPAREN : 'a * 'a -> (svalue,'a) token
    val LBRACKET : 'a * 'a -> (svalue,'a) token
    val LBRACE : 'a * 'a -> (svalue,'a) token
    val COMMA : 'a * 'a -> (svalue,'a) token
    val COLONGT : 'a * 'a -> (svalue,'a) token
    val COLON : 'a * 'a -> (svalue,'a) token
    val ASTERISK : 'a * 'a -> (svalue,'a) token
    val USEOBJ : 'a * 'a -> (svalue,'a) token
    val STDCALL : 'a * 'a -> (svalue,'a) token
    val SIZEOF : 'a * 'a -> (svalue,'a) token
    val IMPORT : 'a * 'a -> (svalue,'a) token
    val FFIAPPLY : 'a * 'a -> (svalue,'a) token
    val EXTERNAL : 'a * 'a -> (svalue,'a) token
    val EXPORT : 'a * 'a -> (svalue,'a) token
    val DOUBLE : 'a * 'a -> (svalue,'a) token
    val CDECL : 'a * 'a -> (svalue,'a) token
    val CAST : 'a * 'a -> (svalue,'a) token
    val BOXED : 'a * 'a -> (svalue,'a) token
    val ATOM : 'a * 'a -> (svalue,'a) token
    val WITHTYPE : 'a * 'a -> (svalue,'a) token
    val WITH : 'a * 'a -> (svalue,'a) token
    val WILD : 'a * 'a -> (svalue,'a) token
    val WHILE : 'a * 'a -> (svalue,'a) token
    val WHERE : 'a * 'a -> (svalue,'a) token
    val VAL : 'a * 'a -> (svalue,'a) token
    val TYPE : 'a * 'a -> (svalue,'a) token
    val THEN : 'a * 'a -> (svalue,'a) token
    val STRUCTURE : 'a * 'a -> (svalue,'a) token
    val STRUCT : 'a * 'a -> (svalue,'a) token
    val SIGNATURE : 'a * 'a -> (svalue,'a) token
    val SIG : 'a * 'a -> (svalue,'a) token
    val SHARING : 'a * 'a -> (svalue,'a) token
    val REC : 'a * 'a -> (svalue,'a) token
    val RAISE : 'a * 'a -> (svalue,'a) token
    val OVERLOAD : 'a * 'a -> (svalue,'a) token
    val OPEN : 'a * 'a -> (svalue,'a) token
    val OP : 'a * 'a -> (svalue,'a) token
    val OF : 'a * 'a -> (svalue,'a) token
    val NONFIX : 'a * 'a -> (svalue,'a) token
    val LOCAL : 'a * 'a -> (svalue,'a) token
    val LET : 'a * 'a -> (svalue,'a) token
    val LAZY : 'a * 'a -> (svalue,'a) token
    val INFIXR : 'a * 'a -> (svalue,'a) token
    val INFIX : 'a * 'a -> (svalue,'a) token
    val INCLUDE : 'a * 'a -> (svalue,'a) token
    val IN : 'a * 'a -> (svalue,'a) token
    val IF : 'a * 'a -> (svalue,'a) token
    val HASH : 'a * 'a -> (svalue,'a) token
    val HANDLE : 'a * 'a -> (svalue,'a) token
    val FUNCTOR : 'a * 'a -> (svalue,'a) token
    val FUN : 'a * 'a -> (svalue,'a) token
    val FN : 'a * 'a -> (svalue,'a) token
    val DARROW : 'a * 'a -> (svalue,'a) token
    val DOT : 'a * 'a -> (svalue,'a) token
    val DO : 'a * 'a -> (svalue,'a) token
    val EXCEPTION : 'a * 'a -> (svalue,'a) token
    val EQTYPE : 'a * 'a -> (svalue,'a) token
    val EQUALOP : 'a * 'a -> (svalue,'a) token
    val END : 'a * 'a -> (svalue,'a) token
    val ELSE : 'a * 'a -> (svalue,'a) token
    val DOTDOTDOT : 'a * 'a -> (svalue,'a) token
    val DATATYPE : 'a * 'a -> (svalue,'a) token
    val CASE : 'a * 'a -> (svalue,'a) token
    val BAR : 'a * 'a -> (svalue,'a) token
    val AS : 'a * 'a -> (svalue,'a) token
    val ARROW : 'a * 'a -> (svalue,'a) token
    val AND : 'a * 'a -> (svalue,'a) token
    val ABSTYPE : 'a * 'a -> (svalue,'a) token
    val CHAR : string * 'a * 'a -> (svalue,'a) token
    val STRING : string * 'a * 'a -> (svalue,'a) token
    val REAL : string * 'a * 'a -> (svalue,'a) token
    val WORD : int * 'a * 'a -> (svalue,'a) token
    val INT0 : int * 'a * 'a -> (svalue,'a) token
    val INT : int * 'a * 'a -> (svalue,'a) token
    val TYVAR : string * 'a * 'a -> (svalue,'a) token
    val ID : string * 'a * 'a -> (svalue,'a) token
    val SEMICOLON : 'a * 'a -> (svalue,'a) token
    val EOF : 'a * 'a -> (svalue,'a) token
  end
end
