(**
 * errors generated by match compiler.
 * @author OSAKA Satoshi
 * @version $Id: MatchError.ppg,v 1.8 2008/03/11 08:53:55 katsu Exp $
 *)
structure MatchError = 
struct
local
  structure TC = TypedCalc
  structure TCU = TypedCalcUtils
  structure RC = RecordCalc
  structure BF = SMLFormat.BasicFormatters
  structure C = Control
  structure A = Absyn
  structure MD = MatchData
  structure BE = BuiltinEnv
  structure T = Types
  structure UE = UserError
  fun bug s = Control.Bug ("MatchData: " ^ s)
in
  fun format_flag x = 
      if !x = 0
      then [SMLFormat.FormatExpression.Term(9,"   -->   ")]
      else [SMLFormat.FormatExpression.Term(9,"         ")]

  (*%
   * @formatter(TC.tppat) TC.format_tppat
   * @formatter(flag) format_flag
   *)
  type rule
  = (*%
     * @format((pat pats* exp) * flag)
     *          flag:flag 9[{pats(pat()())(","+1)} + "=>" + "..."]
     *)
    (TC.tppat list * TC.tpexp) * int ref

  local
    val format_rule' = format_rule
  in
  (*%
   * @formatter(rule) format_rule'
   *)
  exception
  (*%
   * @format(message * rule rules) message +1 rules(rule)(+1)
   *)
  MatchError of string * rule list
  end

  val bindRedundantMessage = "binding redundant"
  val bindNotExhaustiveMessage = "binding not exhaustive"
  val bindBothMessage = "binding redundant and not exhaustive"
  val matchRedundantMessage = "match redundant"
  val matchNotExhaustiveMessage = "match nonexhaustive"
  val matchBothMessage = "match redundant and nonexhaustive"

  fun raiseBindFailExp resultTy loc = 
      let
        val bindExn = case BE.findExn BuiltinName.bindExnName of
                        SOME con => con
                      | NONE => raise bug "bindExn not found"
      in                                 
        RC.RCRAISE
          {exp=RC.RCEXNCONSTRUCT{exn=RC.EXEXN bindExn,
                                 instTyList=nil, 
                                 argExpOpt=NONE, 
                                 loc=loc}, 
           ty=resultTy,
           loc=loc}
      end

  fun raiseMatchFailExp resultTy loc = 
      let
        val matchExn = case BE.findExn BuiltinName.matchExnName of
                         SOME con => con
                       | NONE => raise bug "bindExn not found"
      in                                 
        RC.RCRAISE
          {exp=RC.RCEXNCONSTRUCT{exn=RC.EXEXN matchExn, 
                                 instTyList=nil, 
                                 argExpOpt=NONE, 
                                 loc=loc}, 
           ty=resultTy, 
           loc=loc}
      end
  fun handleFail v resultTy loc =
      RC.RCRAISE {exp=RC.RCVAR (v, loc), ty=resultTy, loc=loc}

  fun raiseMatchCompBugExp resultTy loc =
      RC.RCSEQ
        {expList =
           [RC.RCAPPM
              {funExp =
                 RC.RCFFI
                   (RC.RCFFIIMPORT
                      {ptrExp =
                         RC.RCGLOBALSYMBOL {name = "sml_matchcomp_bug",
                                            kind = A.ForeignCodeSymbol,
                                            ty = BE.PTRty,
                                            loc = loc},
                       ffiTy = TC.FFIFUNTY (NONE, nil, nil, loc)},
                    T.FUNMty ([BE.UNITty], BE.UNITty),
                    loc),
               funTy = T.FUNMty ([BE.UNITty], BE.UNITty),
               argExpList = [RC.RCCONSTANT {const = A.UNITCONST loc,
                                            ty = BE.UNITty,
                                            loc = loc}],
               loc = loc},
            RC.RCRAISE
              {exp = RC.RCEXNCONSTRUCT
                       {exn = RC.EXEXN (BE.lookupExn BuiltinName.matchExnName),
                        instTyList = nil, 
                        argExpOpt = NONE,
                        loc = loc},
               ty = resultTy,
               loc = loc}],
         expTyList = [BE.UNITty, resultTy],
         loc = loc}

  datatype flagKind = Redundant | NotExhaustive
  local
    val errorMessages = ref [] : UE.errorInfo list ref
    val redundantFlag = ref false
    val notExhaustiveFlag = ref false
  in
    fun clearErrorMessages () = errorMessages := []
    fun putErrorMessage (loc, kind, message, rules) =
        errorMessages :=
        (loc, kind, MatchError (message, rules)) :: (! errorMessages)
    fun getErrorMessages () = ! errorMessages
    fun clearFlag Redundant = redundantFlag := false
      | clearFlag NotExhaustive = notExhaustiveFlag := false
    fun setFlag Redundant = redundantFlag := true
      | setFlag NotExhaustive = notExhaustiveFlag := true
    fun isRedundant () = ! redundantFlag
    fun isNotExhaustive () = ! notExhaustiveFlag
  end

  fun haveRedundantRules [] = false
    | haveRedundantRules ((_, flag) :: rules) =
      if !flag then true
      else haveRedundantRules rules

(*
  val print = C.prettyPrint
*)

  fun insertNewline messages =
      let
	fun insert [] = []
	  | insert [message] = [message]
	  | insert (message :: messages) = message :: "\n" :: insert messages
      in
	concat (insert messages)
      end

  fun checkError (MD.Handle v, true, _, rules, loc ) = 
      putErrorMessage (loc, UE.Error, matchRedundantMessage, rules)
    | checkError (MD.Bind, true, true, rules, loc) = 
      putErrorMessage (loc, UE.Error, bindBothMessage, rules)
    | checkError (MD.Bind, true, false, rules, loc) = 
      putErrorMessage (loc, UE.Error, bindRedundantMessage, rules)
    | checkError (MD.Bind, false, true, rules, loc) = 
      putErrorMessage (loc, UE.Warning, bindNotExhaustiveMessage, rules)
    | checkError (MD.Match, true, true, rules, loc) = 
      putErrorMessage (loc, UE.Error, matchBothMessage, rules)
    | checkError (MD.Match, true, false, rules, loc) = 
      putErrorMessage (loc, UE.Error, matchRedundantMessage, rules)
    | checkError (MD.Match, false, true, rules, loc) = 
      putErrorMessage (loc, UE.Warning, matchNotExhaustiveMessage, rules)
    | checkError _ = ()
end
end
