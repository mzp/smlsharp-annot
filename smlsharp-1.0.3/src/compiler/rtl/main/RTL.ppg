(* -*- sml -*- *)
(**
 * x86 mnemonic
 * @copyright (c) 2009, Tohoku University.
 * @author UENO Katsuhiro
 * @version $Id: $
 *)

structure RTL =
struct

  local
    fun format_cnum_str str =
        SMLFormat.BasicFormatters.format_string
          (String.map (fn #"~" => #"-" | x => x) str)
    fun format_cint fmt x =
        format_cnum_str (fmt StringCvt.DEC x)
    fun format_chex fmt x =
        SMLFormat.BasicFormatters.format_string
          ("0x" ^ String.map Char.toLower (fmt StringCvt.HEX x))

(*
    fun format_int64_dec x = format_cint Int64.fmt x
*)
    fun format_int32_dec x = format_cint Int32.fmt x
    fun format_int_dec x = format_cint Int.fmt x
(*
    fun format_word64_hex x = format_chex Word64.fmt x
*)
    fun format_word32_hex x = format_chex Word32.fmt x
    fun format_word8_hex x = format_chex Word8.fmt x
    fun format_word_hex x = format_chex Word.fmt x

    local
      fun left (s,n) = substring (s, size s - n, n)
      fun pad0 (s,n) = if size s > n then s else left ("0000" ^ s, n)
      fun oct3 i = pad0 (Int.fmt StringCvt.OCT i, 3)
      fun hex4 i = pad0 (Int.fmt StringCvt.HEX i, 4)
    in
    fun format_ascii s =
        SMLFormat.BasicFormatters.format_string
          ("\"" ^
           String.translate
             (fn #"\008" => "\\b"
               | #"\012" => "\\f"
               | #"\010" => "\\n"
               | #"\013" => "\\r"
               | #"\009" => "\\t"
               | #"\\" => "\\\\"
               | #"\"" => "\\\""
               | c => if Char.isPrint c andalso ord c < 128 then str c
                      else if ord c < 256 then "\\" ^ oct3 (ord c)
                      else "\\u" ^ hex4 (ord c))
             s ^
             "\"")
    end (* local *)

    fun formatMap foldli formatKey (formatter,prefix,sep,suffix) map =
        foldli
            (fn (k,v,z) =>
                z @ prefix @ formatKey k @ sep @ formatter v @ suffix)
            nil map
    fun formatIDMap x y =
        formatMap VarID.Map.foldli VarID.format_id x y

    fun formatLines (formatItem,indent,break) nil = nil
      | formatLines (formatItem,indent,break) (h::t) =
        indent @ formatItem h @ break @ formatLines (formatItem,indent,break) t

(*
    fun formatLinesR x l = formatLines x (rev l)
*)

  in
(*
 * L6 { x & y }
 * L5 { x + y }
 * L4 { x * y }
 * L2 { x : y }
 *)

  (*% *)
  datatype cc =
      (*% @format "o" *)
      OVERFLOW             (* overflow flag test *)
    | (*% @format "no" *)
      NOTOVERFLOW
    | (*% @format "e" *)
      EQUAL                (* zero flag test *)
    | (*% @format "ne" *)
      NOTEQUAL
    | (*% @format "b" *)
      BELOW                (* carry flag test; unsigned comparison *)
    | (*% @format "be" *)
      BELOWEQUAL
    | (*% @format "a" *)
      ABOVE                (* unsigned comparison *)
    | (*% @format "ae" *)
      ABOVEEQUAL
    | (*% @format "s" *)
      SIGN                 (* sign flag test *)
    | (*% @format "ns" *)
      NOTSIGN
    | (*% @format "l" *)
      LESS                 (* signed comparison *)
    | (*% @format "le" *)
      LESSEQUAL
    | (*% @format "g" *)
      GREATER              (* signed comparison *)
    | (*% @format "ge" *)
      GREATEREQUAL

  (*% *)
  datatype ptrTy =
      (*% @format "Vp" *)
      Void        (* pointer to C data *)
(*
    | (*% @format "cfun" *)
      CFUN        (* pointer to C function *)
*)
    | (*% @format "Dp" *)
      Data        (* pointer to ML heap object *)
    | (*% @format "Cp" *)
      Code        (* pointer to code *)

  (*% @formatter(BoundTypeVarID.id) BoundTypeVarID.format_id *)
  type genericId =
      (*% @format(x) "t" x *)
      BoundTypeVarID.id

  (*% *)
  datatype sign =
      (*% @format *)
      U
    | (*% @format "i" *)
      S

  (*% *)
  datatype ty =
      (*% @format(s) "b" s *)
      Int8 of sign   (* 8 bit integer *)
    | (*% @format(s) "h" s *)
      Int16 of sign  (* 16 bit integer *)
    | (*% @format(s) "w" s *)
      Int32 of sign  (* 32 bit integer *)
    | (*% @format(s) "l" s *)
      Int64 of sign  (* 64 bit integer *)
    | (*% @format "s" *)
      Real32         (* 32 bit single precision floating point *)
    | (*% @format "d" *)
      Real64         (* 64 bit double precision floating point *)
    | (*% @format "t" *)
      Real80         (* 80 bit extended-double precision floating point *)
    | (*% @format(ptr) ptr *)
      Ptr of ptrTy   (* pointer *)
    | (*% @format(ptr) ptr "d" *)
      PtrDiff of ptrTy  (* pointer difference *)
    | (*% @format(id) "G" id *)
      Generic of genericId
    | (*% @format "_" *)
      NoType         (* for untyped temporally register *)

(*
  (*% @formatter(Int64.int) format_int64_dec *)
  type sint64 = Int64.int
  (*% @formatter(Word64.word) format_word64_hex *)
  type uint64 = Word64.word
*)
  (*% @formatter(Int32.int) format_int32_dec *)
  type sint32 = Int32.int
  (*% @formatter(Word32.word) format_word32_hex *)
  type uint32 = Word32.word
  (*% @formatter(int) format_int_dec *)
  type sint16 = int (* Int16.int *)
  (*% @formatter(word) format_word_hex *)
  type uint16 = word (* Word16.word *)
  (*% @formatter(int) format_int_dec *)
  type sint8 = int (* Int8.int *)
  (*% @formatter(Word8.word) format_word8_hex *)
  type uint8 = Word8.word

  (*% @formatter(Loc.loc) Loc.format_loc *)
  type loc = Loc.loc

  (*% @formatter(VarID.id) VarID.format_id *)
  type id = VarID.id

  (*% @formatter(VarID.id) VarID.format_id *)
  type label =
       (*% @format(l) ".L" l *)
       VarID.id

  structure LabelMap = VarID.Map
  structure LabelSet = VarID.Set

  (*% @formatter(ClusterID.id) ClusterID.format_id *)
  type clusterId =
       (*% @format(l) "C" l *)
       ClusterID.id

  (* symbol identifies an address of toplevel objects such as code entries
   * and constant data.
   * Every symbol is unique in a object file.
   * Every symbol has a scope, which is either local or global.
   * Every global symbol is unique among object files which are to be linked
   * each other.
   *)
  (*% *)
  type symbol =
       (*% @format(x) x *)
       string

  (*% *)
  datatype symbolScope =
      (*% @format ".local" *)
      LOCAL
    | (*% @format ".globl" *)
      GLOBAL

(*
  (*% *)
  datatype symbolKind =
      (*% @format({scope, ptrTy}) scope ":" ptrTy *)
      DEFINE_SYMBOL of {scope: symbolScope, ptrTy: ptrTy}
    | (*% @format({ptrTy, linkStub, linkEntry}) ".extern:" ptrTy *)
      (* scope of EXTERN_SYMBOL is always GLOBAL. *)
      EXTERN_SYMBOL of {ptrTy: ptrTy, linkStub: bool, linkEntry: bool}

  (*% *)
  type symbolEnv =
      (*%
       * @format(kind map)
       *)
      symbolKind SEnv.map
*)

  (*% *)
  datatype labelReference =
      (*% @format(ty * label) L2{ label "::" ty } *)
      LABELCAST of ptrTy * labelReference
    | (*% @format(ty) L2{ "NULL:" ty } *)
      NULL of ptrTy
    | (*% @format(l) l *)
      (* code label in the same cluster. *)
      LABEL of label
    | (*% @format(ty * scope * s) L2{ s "(" scope ")" ":" ty } *)
      SYMBOL of ptrTy * symbolScope * symbol
    | (*% @format "." *)
      (* absolute address of beginning of current instruction. *)
      CURRENT_POSITION
    | (*% @format(s) s "$LINK" *)
      (* absolute address of link entry of symbol. *)
      LINK_ENTRY of symbol
    | (*% @format(s) s "$STUB" *)
      (* absolute address of lazy link resolver of symbol. *)
      LINK_STUB of symbol
    | (*% @format "GLOBAL_OFFSET_TABLE" *)
      (* ELF: absolute address of global offset table. *)
      ELF_GOT

  (* NOTE:
   * CURRENT_POSITION, LINK, STUB, and GLOBAL_OFFSET_TABLE are used for
   * generating position independent code (PIC) with dynamic linking.
   * In PIC, their absolute address cannot be decided statically, but
   * distance between code and them are known at compile time.
   * This means that they may be used only for offset calculation.
   *)

(*
  (*
   * labels are classfied according to its scope and object which
   * the label references.
   *)
  (*% *)
  datatype labelReference =
      (* label for code, cluster local, defined in same cluster *)
      (*% @format(l) l *)
      LocalLabel of localLabel
    | (* compile unit local, defined in same compile unit *)
      (*% @format(ty * l) "unit:" l *)
      UnitLabel of ptrTy * string
    | (* global, defined in same compile unit *)
      (*% @format(ty * l) "glbl:" l *)
      GlobalLabel of ptrTy * string
(*
    | (* global, global, defined in other compile unit *)
      (*% @format(ty * l) "extn:" l *)
      ExternLabel of ptrTy * string
*)
    | (* label for address table entry of dynamic linking *)
      (*% @format(ty * l) "link:" l *)
      LinkLabel of ptrTy * string
    | (* label of stub code for dynamic link *)
      (*% @format(l) "stub:" l *)
      LinkStubLabel of string

  (*% *)
  datatype labelScope =
      (*% @format "U$" *)
      COMPILE_UNIT
    | (*% @format "G$" *)
      GLOBAL
*)
(*
  (*% *)
  datatype entryLabel =
      (* handler label *)
      (*% @format(l) "handler:" l *)
      HandlerEntry of localLabel
    | (* label for code, compile unit local *)
      (*% @format(l * {preFrameSize}) "code:" l *)
      UnitCodeEntry of string * {preFrameSize: int}
    | (* label for code, global *)
      (*% @format(l * {preFrameSize}) "Gcode:" l *)
      GlobalCodeEntry of string * {preFrameSize: int}
*)

  (*% *)
  datatype const =
(*
      (*% @format(l) l *)
      SYM of labelReference
    |
*)
      (*% @format({base,label}) L5{ label +1 "-" +2 base } *)
      SYMOFFSET of {base: labelReference, label: labelReference}
(*
    | (*% @format(x) L2{ x ":li" } *)
      INT64 of sint64             (* SINT64 *)
    | (*% @format(x) L2{ x ":l" } *)
      UINT64 of uint64            (* UINT64 *)
*)
    | (*% @format(x) L2{ x ":wi" } *)
      INT32 of sint32             (* SINT32 *)
    | (*% @format(x) L2{ x ":w" } *)
      UINT32 of uint32            (* UINT32 *)
    | (*% @format(x) L2{ x ":hi" } *)
      INT16 of sint16             (* SINT16 *)
    | (*% @format(x) L2{ x ":h" } *)
      UINT16 of uint16            (* UINT16 *)
    | (*% @format(x) L2{ x ":bi" } *)
      INT8 of sint8               (* SINT8 *)
    | (*% @format(x) L2{ x ":b" } *)
      UINT8 of uint8              (* UINT8 *)
    | (*% @format(x) L2{ x ":s" } *)
      REAL32 of string            (* REAL32 *)
    | (*% @format(x) L2{ x ":d" } *)
      REAL64 of string            (* REAL64 *)
    | (*% @format(x) L2{ x ":dH" } *)
      REAL64HI of string          (* NOTYPE *)
    | (*% @format(x) L2{ x ":dL" } *)
      REAL64LO of string          (* NOTYPE *)
(*
    | (* @format(x * y) L5{ x +1 "+" +2 y } *)
      CADD of const * const       (* num * num -> num *)
    | (* @format(x * y) L5{ x +1 "-" +2 y } *)
      CSUB of const * const       (* num * num -> num *)
    | (* @format(x * y) L5{ x +1 "+" +2 y } *)
      CDISP of const * const      (* ptr * int -> ptr *)
    | (* @format(x * y) L3{ x +1 "&" +2 y } *)
      CAND of const * const       (* uint * uint -> uint *)
    | (* @format(x * y) L3{ x +1 "|" +2 y } *)
      CIOR of const * const       (* uint * uint -> uint *)
    | (* @format(x * y) L3{ x +1 "^" +2 y } *)
      CXOR of const * const       (* uint * uint -> uint *)
    | (* @format(x) L6{ "-" x } *)
      CNOT of const               (* uint -> unit *)
    | (* @format(x) L6{ "~" x } *)
      CNEG of const               (* unum -> unum *)
    | (* @format(x) !N0{ "Abs(" x ")" } *)
      CABS of const               (* snum -> snum *)
*)

  (*% *)
  type var =
      (*% @format({id, ty}) L2{ "v" id ":" ty } *)
      {id: id, ty: ty}

  (*% @formatter(BoundTypeVarID.id) BoundTypeVarID.format_id *)
  type tid =
       (*% @format(x) "t" x *)
       BoundTypeVarID.id

  (*% *)
  datatype tag =
      (*% @format "1" *)
      BOXED
    | (*% @format "0" *)
      UNBOXED
    | (*% @format(t) t *)
      GENERIC of tid

  (*% *)
  type format =
      (*%
       * @format({size, align, tag})
       * tag "<" size "," align ">"
       *)
      {size: int, align: int, tag: tag}

  (*% *)
  type slot =
      (*% @format({id, format}) L2{ "s" id ":" format } *)
      {id: id, format: format}

(*
  (*% *)
  datatype slotPlace =
      (*% @format({offset, size}) "POSTFRAME(" offset "," size ")" *)
      POSTFRAME of {offset: int, size: int}
    | (*% @format({offset, size}) "PREFRAME(" offset "," size ")" *)
      PREFRAME of {offset: int, size: int}
  (*% *)
  type slot =
      (*% @format({id, place}) "s" id ":" place *)
      {id: id, place: slotPlace}
*)

(*
  (*% *)
  datatype 'reg alloc =  (* result of register allocation *)
      ALLOC_REG of 'reg
    | ALLOC_FRAME of {id: id, ty: ty, format: FrameLayout.format}
*)

  (*% *)
  datatype x86st =
      (*% @format(n) "%st" n *)
      X86ST of int

  (*% *)
  datatype addr =
      (*% @format(ty * label) L2{ label "::" ty } *)
      ADDRCAST of ptrTy * addr
    | (*% @format(x) x *)
      ABSADDR of labelReference
    | (*% @format(c * e) L5{ c +1 "+" +2 e } *)
      DISP of const * addr
    | (*% @format(var) var *)
      BASE of var
(*
    | (*% @format({index, scale}) L4{ index +1 "*" +2 scale } *)
      INDEX of {index: var, scale: int}
*)
    | (*% @format({base, index, scale})
       * L5{ base +1 "+" +2 L4{ index +3 "*" +4 scale } } *)
      ABSINDEX of {base: labelReference, index: var, scale: int}
    | (*% @format({base, index, scale})
       * L5{ base +1 "+" +2 L4{ index +3 "*" +4 scale } } *)
      BASEINDEX of {base: var, index: var, scale: int}
    | (*% @format({offset, size}) "POSTFRAME(" offset "," size ")" *)
      (* POSTFRAME may be manipulated by CALL. *)
      POSTFRAME of {offset: int, size: int}
    | (*% @format({offset, size}) "PREFRAME(" offset "," size ")" *)
      PREFRAME of {offset: int, size: int}
    | (*% @format(slot) "WORKFRAME(" slot ")" *)
      WORKFRAME of slot
    | (*% @format(offset) "FRAMEINFO(" offset ")" *)
      FRAMEINFO of int
(*
    | (*% @format({id, format}) "s" id ":" format *)
      (* frame slot for spilling variable identified by id. *)
      SLOT of {id: id, format: FrameLayout.format}
*)
(*
    | (*% @format(s) *)
      SLOT of slot
*)

  (*
   *   :             : offset
   *   +-------------+   0
   *   |  PostFrame  |
   *   +-------------+   n
   *   :  Frame      :
   *   |             |
   *   +-------------+   n
   *   |  PreFrame   |
   *   +-------------+   0
   *   :             :
   *)

  (*% *)
  datatype mem =
      (*% @format(x) x *)
      ADDR of addr
    | (*% @format(x) x *)
      SLOT of slot

  (* We don't allow to obtaining address of a SLOT
   * in order to avoid aliasing. *)

  (*% *)
  datatype dst =
      (*% @format(v) v *)
      REG of var
    | (* pair of two registers denoting one 64bit value *)
      (*% @format(ty * {hi,lo}) L2{ !N0{ "{" hi "," lo "}" } ":" ty } *)
      (* notype * notype -> uint64 or sint64 *)
      (* COUPLE is strongly tied with instruction. COUPLE may appear
       * only in special structures specified by target CPU architecture. *)
      COUPLE of ty * {hi: dst, lo: dst}
    | (* memory access *)
      (*% @format(ty * mem) L2{ !N0{ "[" mem "]" } ":" ty } *)
      MEM of ty * mem

  (*% @params(reg) *)
  datatype cast =
      (*% @format reg *)
      N    (* no cast *)
    | (*% @format(ty) L2 { reg "::" ty } *)
      CAST of ty

  (*% *)
  datatype operand =
      (*% @format(c) c *)
      CONST of const
    | (*% @format(cast * dst) cast()(dst) *)
      REF of cast * dst

  (* for convenience *)
  fun REF_ dst = REF (N, dst)

  (*% @params(prefix)
   * @formatter(bool) SmlppgUtil.formatBinaryChoice *)
  datatype handler =
      (* no handler information; if an exception is raised,
       * control goes to outside of the current cluster. *)
      (*% @format *)
      NO_HANDLER
    | (* set of available exception handlers is statically known.
       * If an exception is raised at this point, control goes to either
       * one of the handlers or outside of the current cluster. *)
      (*% @format({outside, handlers: handler handlers})
       * prefix handlers(handler)("," +d) outside()("," +d "OUT",) *)
      HANDLER of {outside: bool, handlers: label list}

  (*% *)
  datatype first =
      (*% @format({label, align, loc}) label ":" *)
      BEGIN of {label: label, align: int, loc: Loc.loc}
    | (*% @format({label, symbol, scope, align, preFrameSize,
       *           stubOptions: stubOptions sopt,
       *           defs:def defs, loc})
       * "        " scope \n
       * {symbol ":\t" ".CODEENTRY"
       *  16[ \n ";" + "defs" + defs(def)("," +)
       *      \n ";" + "preFrameSize=" preFrameSize
       *      sopt(stubOptions)] \n
       * label ":"}
       *
       * @format:stubOptions({forceFrameAlign})
       * \n ";" + "forceFrameAlign=" forceFrameAlign
       *)
      (* If stubOptions is SOME, additional stub code which may allocate
       * a stack frame is generated at code entry. Note that pre-frame
       * is not placed immediately before the current stack if stubOptions
       * is SOME. *)
      CODEENTRY of {label: label, symbol: symbol, scope: symbolScope,
                    align: int, preFrameSize: int,
                    stubOptions: {forceFrameAlign: bool} option,
                    defs: var list, loc: Loc.loc}
    | (*% @format({label, align, defs:def defs, loc})
       * label ":\t" ".HANDLERENTRY {" defs(def)("," +) "}" *)
      HANDLERENTRY of {label: label, align: int,
                       defs: var list, loc: Loc.loc}
    | (*% @format ".enter" *)
      ENTER (* entry point for splicing *)
(*
    | (*% @format({label, align, defs, loc})
       *"\t.globl\t" label \n label ":" \n *)
      ENTRY of {label: entryLabel, align: int, defs: var list, loc: Loc.loc}
    | (*% @format({preFrameSize} * first)
       * first "\t.prologue\t" preFrameSize \n *)
      WITH_PROLOGUE of {preFrameSize: int} * first
*)

(*
  (*% *)
  datatype test =
      (*% @format(ty * op1 * op2) "cmp:" ty "\t" + op1 "," + op2 *)
      TEST_SUB of ty * operand * operand
    | (*% @format(ty * op1 * op2) "test:" ty "\t" + op1 "," + op2 *)
      TEST_AND of ty * operand * operand
*)

  (*
   * Let I be an instruction.
   * Clobbered variables ("clobs" for short) of I are variables such that
   * they are defined, used, and discarded in I as working areas.
   * Since they are defined and discarded in one instruction, they don't
   * appear in the result of liveness analysis. In contrast, they affect
   * register interference information.
   * Usually, clobs interferes with variables in liveIn set and def set of I.
   *)
  (*%
   * @formatter(option) SmlppgUtil.formatEnclosedOpt
   * @formatter(map) formatIDMap
   *)
  datatype instruction =
      (*% @format "nop" *)
      NOP
    | (*% @format ".stabilize" *)
      STABILIZE   (* status must be stable here. *)
    | (*% @format({uses:u us, clobs:clob clobs})
       * {".compute_frame"
       * 8[ \n ";" + "clobbers" + clobs(clob)("," +)
       *    \n ";" + "uses" + "{" us:map(u)(," as ",","+) "}" ]}
       *)
      (* "uses" field keeps track of applied substitution to variables
       * used for bitmap computation. *)
      COMPUTE_FRAME of {uses: var VarID.Map.map, clobs: var list}
    | (*% @format(slot) ".request_slot" + slot *)
      (* request that a new slot is allocated at this point. *)
      REQUEST_SLOT of slot
    | (*% @format(slot) ".require_slot" + slot *)
      (* require that the slot must be available until this point. *)
      REQUIRE_SLOT of slot
    | (*% @format(op1 ops) ".use\t" ops(op1)("," +) *)
      (* ensure that operands are available at this point. *)
      USE of operand list
    | (*% @format(ty * dst * src) "mov:" ty "\t" dst "," + src *)
      MOVE of ty * dst * operand
    | (*% @format(ptrTy * dst * op1) "mva:" ptrTy "\t" dst "," + op1 *)
      MOVEADDR of ptrTy * dst * addr
    | (*% @format({ty, dst, src, clobs:clob clobs})
       * "copy:" ty "\t" dst "," + src + "clobbers" + clobs(clob)("," +) *)
      (* copy between two slots which cannot be copied by one pair of
       * load and store machine instruction. *)
      COPY of {ty: ty, dst: dst, src: operand, clobs: var list}
    | (*% @format({ty, dst, srcAddr, size, defs: df ds, clobs:clob clobs})
       * {"mld:"ty"\t" "[" dst "]" "," + "[" srcAddr "]" "," + size
       * 8[ \n ";" "defs" + ds(df)("," +)
       *    \n ";" "clobbers" + clobs(clob)("," +) ]} *)
      (* copy `size' bytes from `srcAddr' to `dst' slot.
       * The slot must be aligned but srcAddr is not always aligned.
       * defs are variables clobbered by this instruction; their values are
       * undefined. *)
      MLOAD of {ty: ty, dst: slot, srcAddr: addr, size: operand,
                defs: var list, clobs: var list}
    | (*% @format({ty, dstAddr, src, size, defs: df ds, clobs:clob clobs,
       *           global})
       * {"mst:"ty"\t[" dstAddr "]," + "[" src "]" "," + size
       * 8[ \n ";" + "defs" + ds(df)("," +)
       *    \n ";" + "clobbers" + clobs(clob)("," +) ]} *)
      (* copy `size' bytes from `src' slot to `dstAddr'.
       * The slot must be aligned but dstAddr is not always aligned.
       * If global is true, result of this store must be fetchable by other
       * threads.
       * defs are variables clobbered by this instruction; their values are
       * undefined. *)
      MSTORE of {ty: ty, dstAddr: addr, src: slot, size: operand,
                 global: bool, defs: var list, clobs: var list}
(*
    | (*% @format(s * dst * op1) "zext:h"s"\t" dst "," + L2{op1 ":b"} *)
      ZEROEXT8TO16 of sign * dst * operand
    | (*% @format(s * dst * op1) "zext:w"s"\t" dst "," + L2{op1 ":b"} *)
      ZEROEXT8TO32 of sign * dst * operand
    | (*% @format(s * dst * op1) "zext:w"s"\t" dst "," + L2{op1 ":h"} *)
      ZEROEXT16TO32 of sign * dst * operand
*)
(*
    | (*% @format(s * dst * op1) "ext:hb"s"\t" dst "," + op1 *)
      EXT8TO16 of sign * dst * operand
*)
    | (*% @format(s * dst * op1) "ext:wb"s"\t" dst "," + op1 *)
      EXT8TO32 of sign * dst * operand
    | (*% @format(s * dst * op1) "ext:wh"s"\t" dst "," + op1 *)
      EXT16TO32 of sign * dst * operand
    | (*% @format(s * dst * op1) "ext:lw"s"\t" dst "," + op1 *)
      EXT32TO64 of sign * dst * operand
(*
    | (*% @format(s * dst * op1) "dwn:bh"s"\t" dst "," + op1 *)
      DOWN16TO8 of sign * dst * operand
*)
    | (*% @format(s * dst * op1) "dwn:bw"s"\t" dst "," + op1 *)
      DOWN32TO8 of sign * dst * operand
    | (*% @format(s * dst * op1) "dwn:hw"s"\t" dst "," + op1 *)
      DOWN32TO16 of sign * dst * operand
(*
    | (*% @format(dst * op1) "movzbl\t" dst "," + op1 *)
      UINT8TO32 of dst * operand
    | (*% @format(dst * op1) "movzwl\t" dst "," + op1 *)
      UINT16TO32 of dst * operand
    | (*% @format(dst * op1) "cbw\t" dst "," + op1 *)
      SINT8TO16 of dst * operand
    | (*% @format(dst * op1) "cwde\t" dst "," + op1 *)
      SINT16TO32 of dst * operand
    | (*% @format(dst * op1) "cdq\t" dst "," + op1 *)
      SINT32TO64 of dst * operand

    | (*% @format(dst * op1) "movb\t" dst "," + op1 *)
      UINT32TO8 of dst * operand
    | (*% @format(dst * op1) "movb\t" dst "," + op1 *)
      UINT32TO16 of dst * operand
    | (*% @format(dst * op1) "movb\t" dst "," + op1 *)
      SINT32TO8 of dst * operand
    | (*% @format(dst * op1) "movb\t" dst "," + op1 *)
      SINT32TO16 of dst * operand
    | (*% @format(dst * op1) "movb\t" dst "," + op1 *)
      SINT32TO16 of dst * operand
*)
    | (*% @format(ty * dst * op1 * op2) "add:"ty"\t" dst ","+ op1 ","+ op2 *)
      ADD of ty * dst * operand * operand
    | (*% @format(ty * dst * op1 * op2) "sub:"ty"\t" dst ","+ op1 ","+ op2 *)
      SUB of ty * dst * operand * operand
(*
    | (*% @format((ty * dst) * (op1ty * op1) * (op2ty * op2))
       * "mul\t" dst ":" ty ","+ op1 ":" op1ty ","+ op2 ":" op2ty *)
      MUL of (ty * dst) * (ty * operand) * (ty * operand)
    | (*% @format({div: divTy * ddiv, mod: modTy * dmod}
       *          * (op1Ty * op1) * (op2Ty * op2))
       * "divmod\t" "(" ddiv ":" divTy "," dmod ":" modTy ")" "," +
       *            op1 ":" op1Ty "," + op2 ":" op2Ty *)
      DIVMOD of {div: ty * dst, mod: ty * dst} * (ty * operand) * (ty * operand)
*)
    | (*% @format((ty * dst) * (op1ty * op1) * (op2ty * op2))
       * "mul\t" L2{dst ":" ty} ","+
       * L2{op1 ":" op1ty} ","+ L2{op2 ":" op2ty} *)
      MUL of (ty * dst) * (ty * operand) * (ty * operand)
    | (*% @format({div: divTy * ddiv, mod: modTy * dmod}
       *          * (op1Ty * op1) * (op2Ty * op2))
       * "divmod\t"
       * "(Q=" L2{ddiv ":" divTy} ", R=" L2{dmod ":" modTy} ")" "," +
       * L2{op1 ":" op1Ty} "," + L2{op2 ":" op2Ty} *)
      DIVMOD of
      {div: ty * dst, mod: ty * dst} * (ty * operand) * (ty * operand)
    | (*% @format(ty * dst * op1 * op2) "and:"ty"\t" dst ","+ op1 ","+ op2 *)
      AND of ty * dst * operand * operand
    | (*% @format(ty * dst * op1 * op2) "or:"ty"\t" dst ","+ op1 ","+ op2 *)
      OR of ty * dst * operand * operand
    | (*% @format(ty * dst * op1 * op2) "xor:"ty"\t" dst ","+ op1 ","+ op2 *)
      XOR of ty * dst * operand * operand
    | (*% @format(ty * dst * op1 * op2) "shl:"ty"\t" dst ","+ op1 ","+ op2 *)
      LSHIFT of ty * dst * operand * operand
    | (*% @format(ty * dst * op1 * op2) "srl:"ty"\t" dst ","+ op1 ","+ op2 *)
      RSHIFT of ty * dst * operand * operand
    | (*% @format(ty * dst * op1 * op2) "sar:"ty"\t" dst ","+ op1 ","+ op2 *)
      ARSHIFT of ty * dst * operand * operand
    | (*% @format(ty * op1 * op2) "cmp:" ty "\t" op1 "," + op2 *)
      TEST_SUB of ty * operand * operand
    | (*% @format(ty * op1 * op2) "test:" ty "\t" op1 "," + op2 *)
      TEST_AND of ty * operand * operand
    | (*% @format(ty * op1 * op2) "test:" ty "\t" op1 "," + op2 *)
      TEST_LABEL of ptrTy * operand * labelReference
    | (*% @format(ty * dst * op1) "not:"ty"\t" dst ","+ op1 *)
      NOT of ty * dst * operand
    | (*% @format(ty * dst * op1) "neg:"ty"\t" dst ","+ op1 *)
      NEG of ty * dst * operand   (* 2's compliment *)
    | (*% @format(cc * ty * dst * {test})
       * {test + "; for next instruction" \n "set"cc":"ty"\t" dst} *)
      SET of cc * ty * dst * {test: instruction}
(*
    | (*% @format(ty * exp) "push<"ty">\t" exp *)
      PUSH of ty * exp
    | (*% @format(ty * dst) "pop<"ty">\t" dst *)
      POP of ty * dst
*)
    | (*% @format(dst) "mov\t" dst "," + "fp" *)
      LOAD_FP of dst
    | (*% @format(dst) "mov\t" dst "," + "prev_fp" *)
      LOAD_PREV_FP of dst
    | (*% @format(dst) "mov\t" dst "," + "sp" *)
      LOAD_SP of dst
    | (*% @format(dst) "mov\t" dst "," + "retaddr" *)
      LOAD_RETADDR of dst
(*
    | (*% @format(op1) "mov\t" "fp" "," + op1 *)
      SAVE_FP of operand
    | (*% @format(op1) "mov\t" "sp" "," + op1 *)
      SAVE_SP of operand
    | (*% @format(dst) "mov\t" dst "," + "(%esp)" *)
      X86PEEK_STACK of dst
*)
    | (*% @format({ty, dst, symbol, thunk:thunk topt})
       * "la:"ty"\t" dst ","+ symbol topt(thunk)(+ "by using" +,) *)
      LOADABSADDR of {ty: ty, dst: dst, symbol: labelReference,
                      thunk: symbol option}

    | (*% @format(x86) "X86:" x86 *)
      X86 of x86insn

  and x86insn =
      (*% @format(ty * dst * {base, shift, offset, disp})
       * "lea\t" dst "," + base "+" offset "<<" shift "+" disp *)
      X86LEAINT of ty * dst * {base: var, shift: int, offset: var, disp: const}
    | (*% @format(ty * mem) "fld\t" L2{mem ":" ty} *)
      X86FLD of ty * mem             (* push and st(0) <- [mem:ty] *)
    | (*% @format(i) "fld\t" i *)
      X86FLD_ST of x86st             (* push and st(0) <- st(i) *)
    | (*% @format(ty * mem) "fst\t" L2{mem ":" ty} *)
      X86FST of ty * mem             (* [mem:ty] <- st(0) *)
    | (*% @format(ty * mem) "fstp\t" L2{mem ":" ty} *)
      X86FSTP of ty * mem            (* [mem:ty] <- st(0) and pop *)
    | (*% @format(i) "fstp\t" i *)
      X86FSTP_ST of x86st            (* st(i) <- st(0) and pop *)

    | (*% @format(ty * mem) "fadd\t" L2{mem ":" ty} *)
      X86FADD of ty * mem            (* st(0) <- st(0) + [mem:ty] *)
    | (*% @format(i * j) "fadd\t" i "," + j *)
      X86FADD_ST of x86st * x86st    (* st(i) <- st(i) + st(j) *)
    | (*% @format(i) "faddp\t" i *)
      X86FADDP of x86st              (* st(i) <- st(i) + st(0) and pop *)
    | (*% @format(ty * mem) "fsub\t" L2{mem ":" ty} *)
      X86FSUB of ty * mem            (* st(0) <- st(0) - [mem:ty] *)
    | (*% @format(i * j) "fsub\t" i "," + j *)
      X86FSUB_ST of x86st * x86st    (* st(i) <- st(i) - st(j) *)
    | (*% @format(i) "fsubp\t" i *)
      X86FSUBP of x86st              (* st(i) <- st(i) - st(0) and pop *)
    | (*% @format(ty * mem) "fsubr\t" L2{mem ":" ty} *)
      X86FSUBR of ty * mem           (* st(0) <- [mem:ty] - st(0) *)
    | (*% @format(i * j) "fsubr\t" i "," + j *)
      X86FSUBR_ST of x86st * x86st   (* st(i) <- st(j) - st(i) *)
    | (*% @format(i) "fsubrp\t" i *)
      X86FSUBRP of x86st             (* st(i) <- st(0) - st(i) and pop *)
    | (*% @format(ty * mem) "fmul\t" L2{mem ":" ty} *)
      X86FMUL of ty * mem            (* st(0) <- st(0) + [mem:ty] *)
    | (*% @format(i * j) "fmul\t" i "," + j *)
      X86FMUL_ST of x86st * x86st    (* st(i) <- st(i) * st(j) *)
    | (*% @format(i) "fmulp\t" i *)
      X86FMULP of x86st              (* st(i) <- st(i) * st(0) and pop *)
    | (*% @format(ty * mem) "fdiv\t" L2{mem ":" ty} *)
      X86FDIV of ty * mem            (* st(0) <- st(0) / [mem:ty] *)
    | (*% @format(i * j) "fdiv\t" i "," + j *)
      X86FDIV_ST of x86st * x86st    (* st(i) <- st(i) / st(j) *)
    | (*% @format(i) "fdivp\t" i *)
      X86FDIVP of x86st              (* st(i) <- st(i) / st(0) and pop *)
    | (*% @format(ty * mem) "fdivr\t" L2{mem ":" ty} *)
      X86FDIVR of ty * mem           (* st(0) <- [mem:ty] / st(0) *)
    | (*% @format(i * j) "fdivr\t" i "," + j *)
      X86FDIVR_ST of x86st * x86st   (* st(i) <- st(j) / st(i) *)
    | (*% @format(i) "fdivrp\t" i *)
      X86FDIVRP of x86st             (* st(i) <- st(0) / st(i) and pop *)
    | (*% @format "fprem" *)
      X86FPREM                       (* st(0) <- st(0) mod st(1) *)
    | (*% @format "fabs" *)
      X86FABS                        (* st(0) <- abs(st(0)) *)
    | (*% @format "fchs" *)
      X86FCHS                        (* st(0) <- -st(0) *)
    | (*% @format "fincstp\n" *)
      X86FINCSTP                     (* increment stack top pointer *)
    | (*% @format "ffree\t" *)
      X86FFREE of x86st              (* free st(i) *)
    | (*% @format(i) "fxch\t" i *)
      X86FXCH of x86st               (* exchange st(0) and st(i) *)
    | (*% @format(i) "fucom\t" i *)
      X86FUCOM of x86st              (* compare st(0) and st(i) *)
    | (*% @format(i) "fucomp\t" i *)
      X86FUCOMP of x86st             (* compare st(0) and st(i) and pop *)
    | (*% @format "fucompp" *)
      X86FUCOMPP                     (* compare st(0) and st(1) and pop twice *)
(*
    | (*% @format(dst * insn) insn "; fstsw\t" dst *)
      X86FSTSW of dst * instruction  (* store x87 status to dst *)
*)
    | (*% @format({clob, mask}) "fsw_testh\t" clob "," + mask *)
      (* test high byte of x86 control word *)
      X86FSW_TESTH of {clob: var, mask: const}
    | (*%
       * @format({clob, mask, compare})
       * "fsw_maskcmph\t" clob "," + mask "," + compare
       *)
      (* apply mask to high byte of x86 control word and compare *)
      X86FSW_MASKCMPH of {clob: var, mask: const, compare: const}
    | (*% @format(op1) "fldcw\t" op1 *)
      X86FLDCW of mem                (* fcw <- [mem:uint16] *)
    | (*% @format(dst) "fnstcw\t" dst *)
      X86FNSTCW of mem               (* [mem:uint16] <- fcw *)
    | (*% @format "fwait" *)
      X86FWAIT                       (* FPU wait *)
    | (*% @format "fnclex" *)
      X86FNCLEX                      (* clear exception flags *)

  (*% @formatter(bool) SmlppgUtil.formatBinaryChoice *)
  datatype last =
      (*% @format(insn * {nextLabel, handler})
       * {insn
       *  8[ \n {";" + "next " + nextLabel
       *        handler()(\n ";" + "handle =>" +)}]}
       *)
      HANDLE of instruction * {nextLabel: label, handler: handler}
    | (*% @format({test, cc, thenLabel, elseLabel})
       * {test + "; for next instruction" \n
       *  "j"cc"\t" thenLabel + "else" + elseLabel} *)
      CJUMP of {test: instruction, cc: cc,
                thenLabel: label, elseLabel: label}
    | (*% @format({callTo, returnTo, defs: df ds, uses: u us,
       *           handler, needStabilize, postFrameAdjust})
       * {"call\t" callTo
       *  8[ \n {";" + "return to" + returnTo
       *        handler()(\n ";" + "handle =>" +)
       *        \n ";" + "defs" + {ds(df)("," +d)}
       *        \n ";" + "uses" + {us(u)("," +d)}
       *        \n ";" + "postFrameAdjust=" postFrameAdjust
       *        needStabilize()(\n ";" + "need stabilize",)}]}
       *)
      CALL of {callTo: addr, returnTo: label, handler: handler,
               defs: var list, uses: var list,
               needStabilize: bool,
               (* postFrameAdjust holds the additional size of postframe
                * which must be allocated for adjustment when control
                * returns. *)
               postFrameAdjust: int}
    | (*% @format({jumpTo, destinations:label labels})
       * {"jmp\t" jumpTo
       *  8[ \n {";" + "=>" + {labels(label)("," +d)}}]} *)
      JUMP of {jumpTo: addr, destinations: label list}
    | (*% @format({jumpTo, fp, sp, uses:u us, handler})
       * {"jmp\t" jumpTo
       *  8[ \n {";" + "unwind with"
       *         \n ";" + "fp = " fp
       *         \n ";" + "sp = " sp
       *         \n ";" + "uses" + {us(u)("," +d)}
       *         \n handler()(\n ";" + "handle =>"+)}]}
       *)
      UNWIND_JUMP of {jumpTo: addr, sp: operand, fp: operand,
                      uses: var list, handler: handler}
    | (*% @format({preFrameSize, jumpTo, uses:u us})
       * {"jmp\t" jumpTo
       *  8[ \n ";" + "tail call"
       *     \n ";" + "preFrameSize=" preFrameSize
       *     \n ";" + "uses" + {us(u)("," +d)}]}
       *)
      TAILCALL_JUMP of {preFrameSize: int, jumpTo: addr, uses: var list}
    | (*% @format({preFrameSize, stubOptions: stubOptions sopt, uses:u us})
       * {"ret"
       * 8[ \n ";" + "preFrameSize=" preFrameSize
       *    \n ";" + "uses" + {us(u)("," +d)}
       *    sopt(stubOptions)]}
       * @format:stubOptions({forceFrameAlign})
       * \n ";" + "forceFrameAlign=" forceFrameAlign()(,)
       *)
      RETURN of {preFrameSize: int,
                 stubOptions: {forceFrameAlign: bool} option,
                 uses: var list}
(*
    | (*% @format({callTo, returnTo}) "call\t" callTo +"=>"+ returnTo *)
      X86JUMP_BY_CALL of {callTo: label, returnTo: label}
    | (*% @format({destinations:l ls}) "ret\t" ls(l)(",") *)
      X86JUMP_BY_RET of {destinations: label list}
*)
(*
    | (*% @format({preFrameSize} * last)
       * ".epilogue\t" preFrameSize \n "\t" last *)
      WITH_EPILOGUE of {preFrameSize: int} * last
*)
    | (*% @format ".exit" *)
      EXIT  (* end point for splicing *)

  (*% @formatter(lines) formatLines *)
  type block =
      (*% @format(first * insn insns:lines * last)
       *  first \n insns(insn)("        ",\n)  "        " last
       *)
      first * instruction list * last

  (*% @formatter(option) SmlppgUtil.formatOptWithDefault *)
  type frameBitmap =
      (*%
       * @format({source, bits:bit bits})
       * source ":[" { bits(bit)("," +d) "]" }
       * @format:bit(bi bo) bo(bi)("_")
       *)
      {
        source: operand,
        (* bits field holds correspondence between `tid's and bits of
         * frame bitmap. If a tid is n-th (starting with 0) element of bits,
         * frame bit of that tid is n-th bit (LSB is 0) of source.
         * NONE means that there is no tid corresponding to this bit.
         *)
        bits: tid option list
      }

  (*% @formatter(LabelMap.map) formatIDMap *)
  type graph =
      (*% @format(block blocks) blocks(block)(";; block ",\n,\n) *)
      block LabelMap.map

  val emptyGraph =
      LabelMap.empty : graph

  (*%
   * @formatter(lines) formatLines
   * @formatter(option) SmlppgUtil.formatEnclosedOpt
   *)
  type cluster =
      (*%
       * @format({clusterId, frameBitmap: bitmap bitmaps:lines,
       *          preFrameSize, postFrameSize, numHeaderWords,
       *          baseLabel: bl blopt, body, loc})
       * "# begin cluster " clusterId \n
       * "# loc = " loc \n
       * blopt(bl)("# base = ", \n)
       * bitmaps(bitmap)("# frameBitmap: ", \n)
       * "# pre/post = " preFrameSize "/" postFrameSize \n
       * "# numHeaderWords = " numHeaderWords \n
       * body
       * "# end cluster"
       *)
      {
        clusterId: clusterId,
        frameBitmap: frameBitmap list,
        baseLabel: label option,
        body: graph,
        preFrameSize: int,
        postFrameSize: int,
        numHeaderWords: int,
        loc: loc
      }

  (*%
   * @formatter(Word8.word) format_word8_hex
   * @formatter(lines) formatLines
   * @formatter(ascii) format_ascii
   *)
  datatype datum =
      (*% @format(c) ".const" + c *)
      CONST_DATA of const
    | (*% @format(l) ".label" + l *)
      LABELREF_DATA of labelReference
    | (*% @format(w ws) ".byte" + ws(w)(",") *)
      BINARY_DATA of Word8.word list
    | (*% @format(s:ascii) ".ascii" + s *)
      ASCII_DATA of string
    | (*% @format({size}) ".fill" + size *)
      SPACE_DATA of {size: int}
(*
    | (*% @format({align, data: dat dats:lines})
       * ".align" + align \n dats(dat)("\t",\n) *)
      ALIGN_DATA of {align: int, data: data list}
*)

  (*% *)
  datatype dataSection =
      (*% @format ".data" *)
      DATA_SECTION
    | (*% @format ".rodata" *)
      RODATA_SECTION
    | (*% @format ".literal4" *)
      LITERAL32_SECTION
    | (*% @format ".literal8" *)
      LITERAL64_SECTION
    | (*% @format ".cstring" *)
      CSTRING_SECTION

  (*% @formatter(lines) formatLines *)
  type data =
      (*%
       * @format({scope, symbol, aliases: alias aliases, ptrTy, section,
       *          prefix: prefix prefixes:lines, align, data: data datas:lines,
       *          prefixSize})
       * "# begin data" \n
       * "# prefixSize = " prefixSize \n
       * "        " section \n
       * prefixes(prefix)("        ",\n)
       * "        " scope \n
       * symbol ":" + "; DATA:" ptrTy " align=" align \n
       * aliases:lines(alias)(, ":" + "; ALIAS" \n)
       * datas(data)("        ",\n)
       * "# end data"
       *)
      {
        scope: symbolScope,
        symbol: symbol,
        aliases: symbol list,
        ptrTy: ptrTy,
        section: dataSection,
        prefix: datum list,
        align: int,
        data: datum list,
        prefixSize: int
      }

  (*%
   * @formatter(bool) SmlppgUtil.formatBinaryChoice
   * @formatter(option) SmlppgUtil.formatEnclosedOpt
   *)
  datatype topdecl =
      (*% @format({symbol, (*toplevelId,*) toplevelEntry,
                   nextToplevel: next nextOpt,
                   smlPushHandlerLabel,
                   smlPopHandlerLabel})
       * symbol ":\t.toplevel" + toplevelEntry nextOpt(next)(+ "=>" +,) *)
      TOPLEVEL of {symbol: symbol,
                   (*toplevelId: clusterId,*)
                   toplevelEntry: symbol,
                   nextToplevel: symbol option,
                   smlPushHandlerLabel: labelReference,
                   smlPopHandlerLabel: labelReference}
    | (*% @format(cluster) cluster *)
      CLUSTER of cluster
    | (*% @format(data) data *)
      DATA of data
    | (*%
       * @format({scope, symbol, size})
       * "        " scope \n
       * symbol ": .comm" + symbol "," + size
       *)
      BSS of {scope: symbolScope, symbol: symbol, size: int}
    | (*%
       * @format(sym) sym ": ; X86GET_PC_THUNK_BX"
       *)
      X86GET_PC_THUNK_BX of symbol
    | (*%
       * @format({symbol, linkStub, linkEntry, ptrTy})
       * symbol ": .EXTERN" ":" ptrTy
       * linkEntry()(\n symbol "$LINK: .link_entry",)
       * linkStub()(\n symbol "$STUB: .link_stub",)
       *)
      EXTERN of {symbol: symbol, linkStub: bool, linkEntry: bool, ptrTy: ptrTy}
(*
    | (*%
       * @format(sym) sym ": ; NEXT_TOPLEVEL_STUB"
       *)
      NEXT_TOPLEVEL_STUB of symbol
*)

(*
  (*% @formatter(lines) formatLines *)
  type program =
      (*%
       * @format(symbolEnv * dec decs:lines)
       * symbolEnv \n decs(dec)(,\n)
       *)
      symbolEnv * topdecl list
*)

  (*% @formatter(lines) formatLines *)
  type program =
      (*%
       * @format(dec decs:lines)
       * decs(dec)(,\n)
       *)
      topdecl list







(*
  (*% @formatter(lines) formatLines *)
  datatype symbolDef =
      CLUSTER_ENTRY of {scope: symbolScope, clusterId: clusterId}
    | DATA of {scope: symbolScope, ptrTy: ptrTy, section: dataSection,
               prefix: data list, align: int, data: data list,
               prefixSize: int, dataSize: int}
    | BSS of {scope: symbolScope, align: int, size: int}
    | (* scope = GLOBAL *)
      EXTERN of {ptrTy: ptrTy, linkEntry: bool, linkStub: bool}
    | X86GET_PC_THUNK_BX
    | NEXT_TOPLEVEL_STUB
    | ALIAS of labelReference




  datatype symbolKind =
      TEXT of {scope: symbolScope, clusterI



  datatype symbol =
      CLUSTER_ENTRY of {scope: symbolScope, clusterId: clusterId}
    | DATA of {scope: symbolScope, ptrTy: ptrTy}
    | BSS of {scope:




  datatype topdef =


  (*% *)
  type program =
      (*% *)
      {
        clusters: cluster VarID.Map.map, (* clusterId -> cluster *)
        symbols: symbolDef SEnv.map
      }
*)

(*
  (*% @formatter(lines) formatLines *)
  datatype toplevel =
      (*%
       * @format(c)
       * "# cluster begin" 1
       * c 1
       * "# cluster end" 1
       *)
      CLUSTER of cluster
    | (*%
       * @format({symbol, scope, ptrTy, readonly, data:dat dats:lines})
       * scope + symbol 1 symbol ": ; DATA" 1
       * dats(dat)("        ", 1)
       *)
      DATA of {symbol: symbol, scope: symbolScope, ptrTy: ptrTy,
               readonly: bool, data: data list}
    | (*%
       *)
      LINK_ENTRY of symbol
    | (*%
       *)
      LINK_STUB of symbol
    | (*%
       *)
      EXTERN of {symbol: symbol, ptrTy: ptrTy}
    | (*%
       *)
      X86GET_PC_THUNK_BX of symbol
    | (*%
       *)
      NEXT_TOPLEVEL_STUB of string
*)

(*
  datatype toplevel =
      LINK_ENTRY of symbol
    | LINK_STUB of symbol
    | X86GET_PC_THUNK_BX of symbol
    |
    | (*% @format(l) l ": .extern data" 1 *)
      EXTERN_DATA of string
    | (*% @format(l) l ": .extern code" 1 *)
      EXTERN_CODE of string
    | (*% @format(ty * l) l ": .link entry" 1 *)
      LINK_ENTRY of ptrTy * string
    | (*% @format(l) l ": .link stub" 1 *)
      LINK_STUB of string
    | (*% @format(l) l ": .next toplevel stub" 1 *)
      NEXT_TOPLEVEL_STUB of string
*)

(*
  (*% *)
  type program = unit
*)
(*
      (*% @format(tl tls) tls(tl)() *)
      toplevel list
*)

(*
  (*%
   * @formatter(enclosedList) SmlppgUtil.formatListWithEnclosureIfMoreThanOne
   *)
  type linearCluster =
      (*%
       * @format({frameBitmap: bitmap bitmaps:enclosedList,
       *          body, preFrameAligned, loc})
       * "# cluster begin" 1
       * "# loc = " loc 1
       * bitmaps(bitmap)("# frameBitmap: " 1, 1, 1)
       * "# preFrameAligned = " preFrameAligned 1
       * body 1
       * "# cluster end" 1
       *)
      {
        frameBitmap: frameBitmap list,
        body: node list,
        preFrameAligned: bool,
        loc: loc
      }
*)

(*
  (*% *)
  type program =
      (*%
       * @prefix debug_
       * @format({entryCode: code codes,
       *          clusters: cluster clusters,
       *          data: dat dats,
       *          toplevelStubCode: stub stubop})
       * "# EntryCode:" 1
       * codes(code)()
       * clusters(cluster)()
       * "# Data:" 1
       * dats(dat)()
       * "# Toplevel stub code:" 1
       * stubop(stub)()
       *)
       {
         clusters: cluster list,
         data: instruction list
       }
*)

(*


  (*% @formatter(lines) formatLines
      @formatter(linesR) formatLinesR *)
  type focus =
      (*% @format({first, pre: pre pres:linesR, post: post posts:lines, last, context})
       * context 1
       * first 1 pres(pre)("        ",1)
       * "!!!!" 1
       * posts(post)("        ",1)
       * last 1
       * @format:context({label, graph})
       * graph 1
       * ";; block " label
       *)
      {
        first: first,
        pre: instruction list,
        post: instruction list,
        last: last,
        context: {label: label, graph: graph}
      }
*)

  end
end
