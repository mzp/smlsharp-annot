_require "../../../basis/main/StringCvt.smi"
_require "../../../basis/main/List.smi"
_require "../../../basis/main/String.smi"
_require "../../../basis/main/Char.smi"
_require "../../../basis/main/Array.smi"
_require "../../../basis/main/ListPair.smi"
_require "../../../basis/main/Int.smi"
_require "../../../basis/main/General.smi"
_require "../../../basis/main/binary-op.smi"
(*
_require "../../../basis.smi"
*)
_require "../../../ml-yacc-lib.smi"
_require "../../control/main/Loc.ppg.smi"
_require "../../absyn/main/Absyn.ppg.smi"
_require "../../absyn/main/AbsynSQL.ppg.smi"
_require "iml.grm.sig"

structure MLLrVals =
struct
  structure ParserData =
  struct
    type pos = Loc.pos
    type svalue (= boxed)
    type arg = unit
    type result = Absyn.unitparseresult
    structure LrTable =
    struct
      datatype pairlist = datatype LrParser.Token.LrTable.pairlist
      datatype state = datatype LrParser.Token.LrTable.state
      datatype term = datatype LrParser.Token.LrTable.term
      datatype nonterm = datatype LrParser.Token.LrTable.nonterm
      datatype action = datatype LrParser.Token.LrTable.action
      type table = LrParser.Token.LrTable.table
      val numStates : table -> int
      val numRules : table -> int
      val describeActions : table -> state -> (term,action) pairlist * action
      val describeGoto : table -> state -> (nonterm,state) pairlist
      val action : table -> state * term -> action
      val goto : table -> state * nonterm -> state
      val initialState : table -> state
      exception Goto = LrParser.Token.LrTable.Goto
      val mkLrTable : {actions : ((term,action) pairlist * action) array,
                       gotos : (nonterm,state) pairlist array,
                       numStates : int, numRules : int,
                       initialState : state} -> table
    end
    structure Token =
    struct
      structure LrTable =
      struct
        datatype pairlist = datatype LrParser.Token.LrTable.pairlist
        datatype state = datatype LrParser.Token.LrTable.state
        datatype term = datatype LrParser.Token.LrTable.term
        datatype nonterm = datatype LrParser.Token.LrTable.nonterm
        datatype action = datatype LrParser.Token.LrTable.action
        type table = LrParser.Token.LrTable.table
        val numStates : table -> int
        val numRules : table -> int
        val describeActions : table -> state ->
                              (term,action) pairlist * action
        val describeGoto : table -> state -> (nonterm,state) pairlist
        val action : table -> state * term -> action
        val goto : table -> state * nonterm -> state
        val initialState : table -> state
        exception Goto = LrParser.Token.LrTable.Goto
        val mkLrTable : {actions : ((term,action) pairlist * action) array,
                         gotos : (nonterm,state) pairlist array,
                         numStates : int, numRules : int,
                         initialState : state} -> table
      end
      datatype token = datatype LrParser.Token.token
      val sameToken : ('a,'b) token * ('a,'b) token -> bool
    end
    structure Actions =
    struct
      val actions : int * pos *
                    (LrTable.state * (svalue * pos * pos)) list * arg ->
                    LrTable.nonterm * (svalue * pos * pos) *
                    (LrTable.state *(svalue * pos * pos)) list
      val void : svalue
      val extract : svalue -> result
    end
    structure EC =
    struct
      val is_keyword : LrTable.term -> bool
      val noShift : LrTable.term -> bool
      val preferred_change : (LrTable.term list * LrTable.term list) list
      val errtermvalue : LrTable.term -> svalue
      val showTerminal : LrTable.term -> string
      val terms: LrTable.term list
    end
    val table : LrTable.table
  end
  structure Tokens =
  struct
    type ('a,'b) token = ('a,'b) LrParser.Token.token
    type svalue = ParserData.svalue
    val ROLLBACK : 'a * 'a -> (svalue,'a) token
    val COMMIT : 'a * 'a -> (svalue,'a) token
    val BEGIN : 'a * 'a -> (svalue,'a) token
    val DEFAULT : 'a * 'a -> (svalue,'a) token
    val SET : 'a * 'a -> (svalue,'a) token
    val UPDATE : 'a * 'a -> (svalue,'a) token
    val BY : 'a * 'a -> (svalue,'a) token
    val ORDER : 'a * 'a -> (svalue,'a) token
    val DELETE : 'a * 'a -> (svalue,'a) token
    val VALUES : 'a * 'a -> (svalue,'a) token
    val INTO : 'a * 'a -> (svalue,'a) token
    val INSERT : 'a * 'a -> (svalue,'a) token
    val FROM : 'a * 'a -> (svalue,'a) token
    val SELECT : 'a * 'a -> (svalue,'a) token
    val DESC : 'a * 'a -> (svalue,'a) token
    val ASC : 'a * 'a -> (svalue,'a) token
    val SQL : 'a * 'a -> (svalue,'a) token
    val SQLEXEC : 'a * 'a -> (svalue,'a) token
    val SQLEVAL : 'a * 'a -> (svalue,'a) token
    val SQLSERVER : 'a * 'a -> (svalue,'a) token
    val WORD : {radix:StringCvt.radix, digits:string} *  'a * 'a -> (svalue,'a) token
    val WITHTYPE : 'a * 'a -> (svalue,'a) token
    val WITH : 'a * 'a -> (svalue,'a) token
    val WHERE : 'a * 'a -> (svalue,'a) token
    val WHILE : 'a * 'a -> (svalue,'a) token
    val VAL : 'a * 'a -> (svalue,'a) token
    val USEOBJ : 'a * 'a -> (svalue,'a) token
    val USE' : 'a * 'a -> (svalue,'a) token
    val USE : 'a * 'a -> (svalue,'a) token
    val UNDERBAR : 'a * 'a -> (svalue,'a) token
    val TYVAR : (string) *  'a * 'a -> (svalue,'a) token
    val TYPE : 'a * 'a -> (svalue,'a) token
    val THEN : 'a * 'a -> (svalue,'a) token
    val STRUCTURE : 'a * 'a -> (svalue,'a) token
    val STRUCT : 'a * 'a -> (svalue,'a) token
    val STRING : (string) *  'a * 'a -> (svalue,'a) token
    val STDCALL : 'a * 'a -> (svalue,'a) token
    val SPECIAL : (string) *  'a * 'a -> (svalue,'a) token
    val SIZEOF : 'a * 'a -> (svalue,'a) token
    val SIGNATURE : 'a * 'a -> (svalue,'a) token
    val SIG : 'a * 'a -> (svalue,'a) token
    val SHARING : 'a * 'a -> (svalue,'a) token
    val SEMICOLON : 'a * 'a -> (svalue,'a) token
    val RPAREN : 'a * 'a -> (svalue,'a) token
    val REAL : (string) *  'a * 'a -> (svalue,'a) token
    val RBRACKET : 'a * 'a -> (svalue,'a) token
    val RBRACE : 'a * 'a -> (svalue,'a) token
    val REQUIRE : 'a * 'a -> (svalue,'a) token
    val REC : 'a * 'a -> (svalue,'a) token
    val RAISE : 'a * 'a -> (svalue,'a) token
    val PRIVATE : 'a * 'a -> (svalue,'a) token
    val PERIODS : 'a * 'a -> (svalue,'a) token
    val PERIOD : 'a * 'a -> (svalue,'a) token
    val NULL : 'a * 'a -> (svalue,'a) token
    val NAMESPACE : 'a * 'a -> (svalue,'a) token
    val ORELSE : 'a * 'a -> (svalue,'a) token
    val OPEN : 'a * 'a -> (svalue,'a) token
    val OPAQUE : 'a * 'a -> (svalue,'a) token
    val OP : 'a * 'a -> (svalue,'a) token
    val OF : 'a * 'a -> (svalue,'a) token
    val NONFIX : 'a * 'a -> (svalue,'a) token
    val LPAREN : 'a * 'a -> (svalue,'a) token
    val LOCAL : 'a * 'a -> (svalue,'a) token
    val LET : 'a * 'a -> (svalue,'a) token
    val LBRACKET : 'a * 'a -> (svalue,'a) token
    val LBRACE : 'a * 'a -> (svalue,'a) token
    val INTERFACE : 'a * 'a -> (svalue,'a) token
    val INT : {radix:StringCvt.radix, digits:string} *  'a * 'a -> (svalue,'a) token
    val INTLAB : string *  'a * 'a -> (svalue,'a) token
    val INFIXR : 'a * 'a -> (svalue,'a) token
    val INFIX : 'a * 'a -> (svalue,'a) token
    val INCLUDE : 'a * 'a -> (svalue,'a) token
    val IMPORT : 'a * 'a -> (svalue,'a) token
    val IN : 'a * 'a -> (svalue,'a) token
    val IF : 'a * 'a -> (svalue,'a) token
    val ID : (string) *  'a * 'a -> (svalue,'a) token
    val HASH : 'a * 'a -> (svalue,'a) token
    val HANDLE : 'a * 'a -> (svalue,'a) token
    val FUNCTOR : 'a * 'a -> (svalue,'a) token
    val FUN : 'a * 'a -> (svalue,'a) token
    val FN : 'a * 'a -> (svalue,'a) token
    val FFIAPPLY : 'a * 'a -> (svalue,'a) token
    val EXPORT : 'a * 'a -> (svalue,'a) token
    val EXTERNAL : 'a * 'a -> (svalue,'a) token
    val EXCEPTION : 'a * 'a -> (svalue,'a) token
    val EQTYVAR : (string) *  'a * 'a -> (svalue,'a) token
    val EQTYPE : 'a * 'a -> (svalue,'a) token
    val EQ : 'a * 'a -> (svalue,'a) token
    val END : 'a * 'a -> (svalue,'a) token
    val ELSE : 'a * 'a -> (svalue,'a) token
    val DO : 'a * 'a -> (svalue,'a) token
    val DATATYPE : 'a * 'a -> (svalue,'a) token
    val DARROW : 'a * 'a -> (svalue,'a) token
    val COMMA : 'a * 'a -> (svalue,'a) token
    val COLON : 'a * 'a -> (svalue,'a) token
    val CHAR : (string) *  'a * 'a -> (svalue,'a) token
    val CDECL : 'a * 'a -> (svalue,'a) token
    val CAST : 'a * 'a -> (svalue,'a) token
    val CASE : 'a * 'a -> (svalue,'a) token
    val BUILTIN : 'a * 'a -> (svalue,'a) token
    val BAR : 'a * 'a -> (svalue,'a) token
    val ATTRIBUTE : 'a * 'a -> (svalue,'a) token
    val AT : 'a * 'a -> (svalue,'a) token
    val ASTERISK : 'a * 'a -> (svalue,'a) token
    val AS : 'a * 'a -> (svalue,'a) token
    val ARROW : 'a * 'a -> (svalue,'a) token
    val ANDALSO : 'a * 'a -> (svalue,'a) token
    val AND : 'a * 'a -> (svalue,'a) token
    val ABSNAMESPACE : 'a * 'a -> (svalue,'a) token
    val ABSTYPE : 'a * 'a -> (svalue,'a) token
    val EOF : 'a * 'a -> (svalue,'a) token
  end
end
